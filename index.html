<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <link rel="manifest" href="manifest.webmanifest">
  <meta name="theme-color" content="#f6f6f6">

  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">

  <script>
    //
    //  ███████╗███████╗██████╗     ██╗██████╗ ███████╗
    //  ██╔════╝██╔════╝██╔══██╗    ██║██╔══██╗██╔════╝
    //  █████╗  ███████╗██████╔╝    ██║██║  ██║█████╗
    //  ██╔══╝  ╚════██║██╔═══╝     ██║██║  ██║██╔══╝
    //  ███████╗███████║██║         ██║██████╔╝███████╗
    //  ╚══════╝╚══════╝╚═╝         ╚═╝╚═════╝ ╚══════╝
    //
    // ┌────────────────────────────────────────────────┐
    // │ ESP IDE  : FREE MicroPython WEB IDE            │
    // │ AUTHOR   : Milan Špaček                        │
    // │ WEB      : https://espide.eu                   │
    // │ LICENSE  : AGPL-3.0                            │
    // │                                                │
    // │ "CODE IS OPEN — IMPROVEMENTS MUST STAY OPEN"   │
    // │ Please contribute your improvements back       │
    // └────────────────────────────────────────────────┘
    //
    // ┌────────────────────────────────────────────────┐
    // │   Optional startup overrides.                  │
    // └────────────────────────────────────────────────┘
    //
    // Set force_toolbox to a toolbox filename (e.g. "toolbox_ESPBIT.xml") to lock processor selection.
    var force_toolbox = null;

    // Set hide_filemanager to true to disable the File Manager icon in the top bar.
    var hide_filemanager = null;

    const SW_VERSION = "2026-01-29-i18n-only";
    console.log(`ESP IDE v${SW_VERSION}`);

  </script>


  <script>
    // Scale the viewport so the UI keeps the same design size on mobile.
    (function(){
      const W = 615;   // Design width in px.
      const H = 615 ;  // Design height in px.
      const meta = document.querySelector('meta[name=viewport]');
      let currentScale = 1;
      let locking = false;
      let t = 0;

      // Calculate the best scale for the current screen size.
      function desiredScale(useScreen=true){
        // screen.* is in CSS pixels and does not change with meta zoom.
        const vw = useScreen ? screen.width  : (visualViewport ? visualViewport.width  : innerWidth);
        const vh = useScreen ? screen.height : (visualViewport ? visualViewport.height : innerHeight);
        return Math.max(0.1, Math.min(0.9, Math.min(vw / W, vh / H)));
      }

      // Apply the scale and lock changes while the layout settles.
      function applyScale(s){
        if (Math.abs(s - currentScale) < 0.01) return; // Ignore tiny changes.
        locking = true;
        currentScale = s;
        meta.setAttribute('content',
          `width=${W}, initial-scale=${s}, minimum-scale=${s}, maximum-scale=${s}, user-scalable=no, viewport-fit=cover`);
        // Unlock after layout settles.
        setTimeout(()=> locking = false, 200);
      }

      // Recompute the scale, but do it once per resize burst.
      function recalc(){
        if (locking) return;
        clearTimeout(t);
        // Delay a bit to avoid many reflows while resizing.
        t = setTimeout(()=> applyScale(desiredScale(/*useScreen=*/true)), 150);
      }

      // First pass uses the real viewport. Next uses screen size.
      applyScale(desiredScale(/*useScreen=*/false));

      // Listen to orientation and resize changes.
      addEventListener('orientationchange', recalc, {passive:true});
      addEventListener('resize',             recalc, {passive:true});
      // Visual viewport gives better results on mobile.
      if (window.visualViewport) visualViewport.addEventListener('resize', recalc, {passive:true});

      console.log("recalculate");

    })();
  </script>


  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-capable" content="yes">

  <!-- Google Analytics tag (gtag.js) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-N9Q5VE157X"></script>
  <script>
      window.dataLayer = window.dataLayer || [];
      // Send a Google Analytics event.
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-N9Q5VE157X');
  </script>






  <!-- Load the main assets. Use defer to avoid blocking render. -->
  <link rel="stylesheet" href="css/xterm.css?v=2026-01-29">
  <script src="js/xterm.js?v=2026-01-29"></script>
  <script src="js/split.min.js?v=2026-01-29"></script>
  <script src="js/ace.js?v=2026-01-29" defer></script>
  <script src="js/ext-language_tools.js?v=2026-01-29" defer></script>
  <script src="js/blockly_compressed.js?v=2026-01-29" defer></script>
  <script src="js/blocks_compressed.js?v=2026-01-29" defer></script>
  <script src="js/python_compressed.js?v=2026-01-29" defer></script>
  <script src="js/sweetalert2.all.min.js?v=2026-01-29"></script>
  <link rel="stylesheet" href="css/sweetalert2.min.css?v=2026-01-29">

  <!-- Drivers for USB Serial and Bluetooth -->
  <script src="js/repl_web_usb_serial.js?v=2026-01-29" defer></script>
  <script src="js/repl_web_bluetooth_serial.js?v=2026-01-29" defer></script>

  <!-- Dialog fallback for Electron -->
  <script src="js/custom-dialog.js?v=2026-01-29"></script>

  <!-- Virtual joystick (vendor code) -->
  <script>
    // Vendor joystick code. It draws a joystick and reports its position.
    // It also includes internal helper functions for drawing and input.
    let StickStatus={xPosition:0,yPosition:0,x:0,y:0,pressed:0};var JoyStick=function(t,e,i){var o=void 0===(e=e||{}).title?"joystick":e.title,n=void 0===e.width?0:e.width,a=void 0===e.height?0:e.height,r=void 0===e.internalFillColor?"#AAAAAA":e.internalFillColor,d=void 0===e.internalLineWidth?2:e.internalLineWidth,s=void 0===e.internalStrokeColor?"#333333":e.internalStrokeColor,c=void 0===e.externalLineWidth?2:e.externalLineWidth,u=void 0===e.externalStrokeColor?"#808080":e.externalStrokeColor,h=void 0===e.autoReturnToCenter||e.autoReturnToCenter;i=i||function(t){};var S=document.getElementById(t);S.style.touchAction="none";var l=document.createElement("canvas");l.id=o,0===n&&(n=S.clientWidth),0===a&&(a=S.clientHeight),l.width=n,l.height=a,S.appendChild(l);var f=l.getContext("2d"),k=0,g=2*Math.PI,x=(l.width-(l.width/2+10))/2,v=x+5,w=x+30,p=l.width/2,P=l.height/2,m=(l.width,l.height,p),y=P,E=void 0,T=void 0;function drawExternal(){f.beginPath(),f.arc(p,P,w,0,g,!1),f.lineWidth=c,f.strokeStyle=u,f.stroke()}function drawInternal(){f.beginPath(),m<x&&(m=v),m+x>l.width&&(m=l.width-v),y<x&&(y=v),y+x>l.height&&(y=l.height-v),f.arc(m,y,x,0,g,!1);var t=f.createRadialGradient(p,P,5,p,P,200);t.addColorStop(0,r),t.addColorStop(1,s),f.fillStyle=t,f.fill(),f.lineWidth=d,f.strokeStyle=s,f.stroke()}"ontouchstart"in document.documentElement?(l.addEventListener("touchstart",(function onTouchStart(t){k=1}),!1),document.addEventListener("touchmove",(function onTouchMove(t){1===k&&t.targetTouches[0].target===l&&(m=t.targetTouches[0].pageX,y=t.targetTouches[0].pageY,E=m,T=y,"BODY"===l.offsetParent.tagName.toUpperCase()?(m-=l.offsetLeft,y-=l.offsetTop):(m-=l.offsetParent.offsetLeft,y-=l.offsetParent.offsetTop),f.clearRect(0,0,l.width,l.height),drawExternal(),drawInternal(),StickStatus.xPosition=m,StickStatus.yPosition=y,StickStatus.x=((m-p)/v*100).toFixed(),StickStatus.y=((y-P)/v*100*-1).toFixed(),StickStatus.pressed=1,i(StickStatus))}),!1),document.addEventListener("touchend",(function onTouchEnd(t){if(!E||!T||t.changedTouches.length>0&&(Math.abs(t.changedTouches[0].pageX-E)>10||Math.abs(t.changedTouches[0].pageY-T)>10))return;E=void 0,T=void 0,k=0,h&&(m=p,y=P);f.clearRect(0,0,l.width,l.height),drawExternal(),drawInternal(),StickStatus.xPosition=m,StickStatus.yPosition=y,StickStatus.x=((m-p)/v*100).toFixed(),StickStatus.y=((y-P)/v*100*-1).toFixed(),StickStatus.pressed=0,i(StickStatus)}),!1)):(l.addEventListener("mousedown",(function onMouseDown(t){k=1}),!1),document.addEventListener("mousemove",(function onMouseMove(t){1===k&&(m=t.pageX,y=t.pageY,"BODY"===l.offsetParent.tagName.toUpperCase()?(m-=l.offsetLeft,y-=l.offsetTop):(m-=l.offsetParent.offsetLeft,y-=l.offsetParent.offsetTop),f.clearRect(0,0,l.width,l.height),drawExternal(),drawInternal(),StickStatus.xPosition=m,StickStatus.yPosition=y,StickStatus.x=((m-p)/v*100).toFixed(),StickStatus.y=((y-P)/v*100*-1).toFixed(),StickStatus.pressed=1,i(StickStatus))}),!1),document.addEventListener("mouseup",(function onMouseUp(t){k=0,h&&(m=p,y=P);f.clearRect(0,0,l.width,l.height),drawExternal(),drawInternal(),StickStatus.xPosition=m,StickStatus.yPosition=y,StickStatus.x=((m-p)/v*100).toFixed(),StickStatus.y=((y-P)/v*100*-1).toFixed(),StickStatus.pressed=0,i(StickStatus)}),!1)),drawExternal(),drawInternal(),this.GetWidth=function(){return l.width},this.GetHeight=function(){return l.height},this.GetPosX=function(){return m},this.GetPosY=function(){return y},this.GetX=function(){return((m-p)/v*100).toFixed()},this.GetY=function(){return((y-P)/v*100*-1).toFixed()}};
  </script>


  <!-- App version and changelog and toolboxex and CPU features -->
  <script>
    // Global state used by the UI and toolbox.
    var originalToolboxXML = "";   // Keep the clean toolbox from startup.
    var userSettings = null; // Example: { processor: "ESP32", filters: { "Komunikace": {enabled: true, subcategories: {"Komunikace_0": true, "Komunikace_1": true} }, ... } }

    var extensions = JSON.parse(localStorage.getItem("extensions") || "{}");   // {name:{js,xml,enabled}}
    var addons_toolbox = "";   // Merged XML for enabled extensions.

    // Map each processor to its toolbox XML file.
    const TOOLBOX_MAP = {
      ESP32: "toolbox_ESP32.xml",
      ESP32C3: "toolbox_ESP32C3.xml",
      ESP32S3: "toolbox_ESP32S3.xml",
      ESP8266: "toolbox_ESP8266.xml",
      RP2040:  "toolbox_RP2040.xml",
      RP2040_Picoed: "toolbox_RP2040_picoed.xml",
	    OMG_ESPBit: "toolbox_ESPBIT.xml"
    };


    // Simple capability flags for each processor.
    const BOARD_CAPS = {
      ESP32:         { ble: true },
      ESP32C3:       { ble: true },
      ESP32S3:       { ble: true },
      ESP8266:       { ble: false },  // no BLE
      RP2040:        { ble: false },
      RP2040_Picoed: { ble: false },
	  OMG_ESPBit:    { ble: false }
    };

    function normalizeForcedToolbox(value) {
      if (value === null || typeof value === "undefined") return "";
      const text = String(value).trim();
      if (!text) return "";
      const lowered = text.toLowerCase();
      if (lowered === "none" || lowered === "null") return "";
      return text;
    }

    function resolveProcessorForToolbox(toolboxName) {
      if (!toolboxName) return null;
      const normalized = String(toolboxName).trim();
      return Object.keys(TOOLBOX_MAP).find((key) => TOOLBOX_MAP[key] === normalized) || null;
    }

    function isHideFileManagerEnabled() {
      if (hide_filemanager === true) return true;
      if (hide_filemanager === false || hide_filemanager === null || typeof hide_filemanager === "undefined") {
        return false;
      }
      return String(hide_filemanager).trim().toLowerCase() === "true";
    }

    function applyFileManagerVisibility() {
      const hide = isHideFileManagerEnabled();
      const cover = document.getElementById('fileManagerCover');
      const fmArea = document.getElementById('fileManagerArea');
      if (!cover || !fmArea) return;
      if (hide) {
        if (!fmArea.dataset.onclick) {
          fmArea.dataset.onclick = fmArea.getAttribute('onclick') || '';
        }
        fmArea.removeAttribute('onclick');
        fmArea.style.cursor = 'default';
        cover.style.display = 'block';
      } else {
        if (fmArea.dataset.onclick && !fmArea.getAttribute('onclick')) {
          fmArea.setAttribute('onclick', fmArea.dataset.onclick);
        }
        fmArea.style.cursor = 'pointer';
        cover.style.display = 'none';
      }
    }


    // Version string and changelog text for the UI.
    let ESPIDE_VERSION = "";
    let ESPIDE_CHANGELOG = "";
    let espideChangelogLang = null;
    let espideChangelogLoadId = 0;
    let espideChangelogLoading = null;

    function normalizeChangelogLang(lang) {
      if (!lang) return "en";
      const lowered = String(lang).toLowerCase();
      return lowered.startsWith("cs") ? "cs" : "en";
    }

    function resolveChangelogUrl(lang) {
      const normalized = normalizeChangelogLang(lang);
      return normalized === "cs" ? "changelog_cs.txt" : "changelog_en.txt";
    }

    function updateVersionText() {
      const t1 = document.getElementById('menuVersionText');
      if (t1) t1.textContent = ESPIDE_VERSION || "";
    }

    function loadChangelog(lang) {
      const normalized = normalizeChangelogLang(lang);
      if (espideChangelogLoading && espideChangelogLang === normalized) return espideChangelogLoading;
      if (espideChangelogLang === normalized && ESPIDE_CHANGELOG) return Promise.resolve();
      const requestId = ++espideChangelogLoadId;
      espideChangelogLang = normalized;
      const url = resolveChangelogUrl(normalized);
      espideChangelogLoading = (async () => {
        const res = await fetch(url, { cache: "no-store" });
        if (!res.ok) throw new Error(`Changelog load failed: ${res.status}`);
        const raw = await res.text();
        if (requestId !== espideChangelogLoadId) return;
        ESPIDE_CHANGELOG = raw.trimEnd();
        const firstLine = raw.split(/\r?\n/).find((line) => line.trim().length > 0) || "";
        ESPIDE_VERSION = firstLine.trim();
        updateVersionText();
      })().catch((e) => {
        console.warn("Changelog load failed.", e);
        if (requestId === espideChangelogLoadId) {
          espideChangelogLang = null;
        }
      }).finally(() => {
        if (requestId === espideChangelogLoadId) {
          espideChangelogLoading = null;
        }
      });
      return espideChangelogLoading;
    }




    // === I18N (language packs) =========================================
    // This block controls all UI translations.
    // It loads JSON packs and updates HTML elements that use data-i18n* attributes.
    // It also loads Blockly language files and stores the choice.
    const I18N_DEFAULT = "en";
    // JSON pack path, relative to index.html.
    const I18N_URL_TEMPLATE = "i18n/{lang}.json";


    // Blockly language JS path and fallback language.
    const BLOCKLY_LANG_URL_TEMPLATE = "js/{lang}.js";
    const BLOCKLY_LANG_FALLBACK = "cs";

    let currentLanguage = I18N_DEFAULT;
    let activeLanguagePack = {};
    let currentBlocklyLanguage = null;
    let blocklyLanguageReady = Promise.resolve();
    let pendingBlocklyLocaleRefresh = false;

    // Normalize input like "cs-CZ" or "en-US" to "cs" or "en".
    function normalizeLanguage(lang) {
      if (!lang) return I18N_DEFAULT;
      const lowered = String(lang).toLowerCase();
      if (lowered.startsWith("cs") || lowered.startsWith("cz")) return "cs";
      if (lowered.startsWith("en")) return "en";
      return I18N_DEFAULT;
    }

    // Build the URL for the UI language JSON pack.
    function resolveLangUrl(lang) {
      return I18N_URL_TEMPLATE.replace("{lang}", lang);
    }

    // Build the URL for the Blockly language JS file.
    function resolveBlocklyLangUrl(lang) {
      return BLOCKLY_LANG_URL_TEMPLATE.replace("{lang}", lang);
    }

    function stripToolboxWrapper(xmlText) {
      const text = (xmlText || "").trim();
      return text
        .replace(/^<\?xml[^>]*>\s*/i, "")
        .replace(/^<xml[^>]*>/i, "")
        .replace(/<\/xml>\s*$/i, "");
    }

    function mergeToolboxXml(baseXml, extraXml) {
      if (!baseXml) return "";
      return baseXml.replace(/<\/xml>\s*$/, "") + (extraXml || "") + "</xml>";
    }

    function translateToolboxXml(xmlText) {
      if (!xmlText || !/\<xml[\s>]/i.test(xmlText)) return xmlText;
      try {
        const parser = new DOMParser();
        const doc = parser.parseFromString(xmlText, "text/xml");
        const nodes = doc.querySelectorAll("category, label, button, field");
        nodes.forEach((node) => {
          const tag = node.nodeName.toLowerCase();
          const key =
            node.getAttribute("data-i18n") ||
            node.getAttribute("i18n") ||
            (tag === "category"
              ? node.getAttribute("data-i18n-name") || node.getAttribute("i18n-name")
              : tag === "field"
                ? node.getAttribute("data-i18n-text") ||
                  node.getAttribute("i18n-text") ||
                  node.getAttribute("data-i18n-value") ||
                  node.getAttribute("i18n-value")
                : node.getAttribute("data-i18n-text") || node.getAttribute("i18n-text"));
          if (!key) return;
          const translated = t(key);
          if (tag === "category") node.setAttribute("name", translated);
          else if (tag === "label" || tag === "button") node.setAttribute("text", translated);
          else if (tag === "field") node.textContent = translated;
        });
        const serialized = new XMLSerializer().serializeToString(doc.documentElement);
        return serialized.replace(/^<\?xml[^>]*>\s*/i, "");
      } catch (e) {
        console.warn("Toolbox translation failed:", e);
        return xmlText;
      }
    }

    function buildToolboxXmlForLocale(options = {}) {
      if (!originalToolboxXML) return "";
      const merged = mergeToolboxXml(originalToolboxXML, addons_toolbox);
      const filters = (options.applyFilters === false) ? {} : (userSettings?.filters || {});
      const filtered = filterToolboxWithFilters(merged, filters);
      return translateToolboxXml(filtered);
    }

    function applyToolboxXml(xmlText) {
      if (!xmlText) return;
      const toolboxEl = document.getElementById("toolbox");
      if (toolboxEl) toolboxEl.innerHTML = stripToolboxWrapper(xmlText);
      if (!window.Blockly || typeof Blockly.getMainWorkspace !== "function") return;
      const ws = Blockly.getMainWorkspace();
      if (!ws) return;
      if (!/\<category[\s>]/i.test(xmlText)) return; // avoid toolbox mode errors
      try {
        ws.updateToolbox(xmlText);
        queueToolboxIconInject();
      } catch (e) {
        console.warn("Blockly toolbox refresh failed:", e);
      }
    }

    // === Toolbox Category Icons ===
    const CATEGORY_ICON_DEFS = [
      { key: "toolbox.categories.logic", svg: '<svg viewBox="0 0 24 24" fill="currentColor"><path d="M12 2L4 7v10l8 5 8-5V7l-8-5zm0 2.5L17.5 8 12 11.5 6.5 8 12 4.5zM5.5 9.5l5.5 3v6.5l-5.5-3.5v-6zm13 0v6l-5.5 3.5V13l5.5-3z"/></svg>' },
      { key: "toolbox.categories.loops", svg: '<svg viewBox="0 0 24 24" fill="currentColor"><path d="M12 4V1L8 5l4 4V6c3.31 0 6 2.69 6 6 0 1.01-.25 1.97-.7 2.8l1.46 1.46C19.54 15.03 20 13.57 20 12c0-4.42-3.58-8-8-8zm0 14c-3.31 0-6-2.69-6-6 0-1.01.25-1.97.7-2.8L5.24 7.74C4.46 8.97 4 10.43 4 12c0 4.42 3.58 8 8 8v3l4-4-4-4v3z"/></svg>' },
      { key: "toolbox.categories.math", svg: '<svg viewBox="0 0 24 24" fill="currentColor"><path d="M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-5 14h-2v-4H8v-2h4V7h2v4h4v2h-4v4z"/></svg>' },
      { key: "toolbox.categories.lists", svg: '<svg viewBox="0 0 24 24" fill="currentColor"><path d="M3 13h2v-2H3v2zm0 4h2v-2H3v2zm0-8h2V7H3v2zm4 4h14v-2H7v2zm0 4h14v-2H7v2zM7 7v2h14V7H7z"/></svg>' },
      { key: "toolbox.categories.text", svg: '<svg viewBox="0 0 24 24" fill="currentColor"><path d="M5 4v3h5.5v12h3V7H19V4H5z"/></svg>' },
      { key: "toolbox.categories.variables", svg: '<svg viewBox="0 0 24 24" fill="currentColor"><path d="M20 3H4c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16H4V5h16v14zm-8-2h2v-4h4v-2h-4V7h-2v4H8v2h4v4z"/></svg>' },
      { key: "toolbox.categories.functions", svg: '<svg viewBox="0 0 24 24" fill="currentColor"><path d="M20.5 11H19V7c0-1.1-.9-2-2-2h-4V3.5C13 2.12 11.88 1 10.5 1S8 2.12 8 3.5V5H4c-1.1 0-1.99.9-1.99 2v3.8H3.5c1.49 0 2.7 1.21 2.7 2.7s-1.21 2.7-2.7 2.7H2V20c0 1.1.9 2 2 2h3.8v-1.5c0-1.49 1.21-2.7 2.7-2.7s2.7 1.21 2.7 2.7V22H17c1.1 0 2-.9 2-2v-4h1.5c1.38 0 2.5-1.12 2.5-2.5S21.88 11 20.5 11z"/></svg>' },
      { key: "toolbox.categories.inputs", svg: '<svg viewBox="0 0 24 24" fill="currentColor"><path d="M9 3L5 6.99h3V14h2V6.99h3L9 3zm7 14.01V10h-2v7.01h-3L15 21l4-3.99h-3z"/></svg>' },
      { key: "toolbox.categories.outputs", svg: '<svg viewBox="0 0 24 24" fill="currentColor"><path d="M9 3L5 6.99h3V14h2V6.99h3L9 3zm7 14.01V10h-2v7.01h-3L15 21l4-3.99h-3z"/></svg>' },
      { key: "toolbox.categories.time", svg: '<svg viewBox="0 0 24 24" fill="currentColor"><path d="M11.99 2C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8zm.5-13H11v6l5.25 3.15.75-1.23-4.5-2.67V7z"/></svg>' },
      { key: "toolbox.categories.program", svg: '<svg viewBox="0 0 24 24" fill="currentColor"><path d="M9.4 16.6L4.8 12l4.6-4.6L8 6l-6 6 6 6 1.4-1.4zm5.2 0l4.6-4.6-4.6-4.6L16 6l6 6-6 6-1.4-1.4z"/></svg>' },
      { key: "toolbox.categories.display", svg: '<svg viewBox="0 0 24 24" fill="currentColor"><path d="M21 2H3c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h7v2H8v2h8v-2h-2v-2h7c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm0 14H3V4h18v12z"/></svg>' },
      { key: "toolbox.categories.sensors", svg: '<svg viewBox="0 0 24 24" fill="currentColor"><path d="M20 9V7c0-1.1-.9-2-2-2h-3c0-1.66-1.34-3-3-3S9 3.34 9 5H6c-1.1 0-2 .9-2 2v2c-1.66 0-3 1.34-3 3s1.34 3 3 3v4c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2v-4c1.66 0 3-1.34 3-3s-1.34-3-3-3zM7.5 11.5c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5S9.83 13 9 13s-1.5-.67-1.5-1.5zM16 17H8v-2h8v2zm-1-4c-.83 0-1.5-.67-1.5-1.5S14.17 10 15 10s1.5.67 1.5 1.5S15.83 13 15 13z"/></svg>' },
      { key: "toolbox.categories.motors", svg: '<svg viewBox="0 0 24 24" fill="currentColor"><path d="M7 2v11h3v9l7-12h-4l4-8H7z"/></svg>' },
      { key: "toolbox.categories.neopixel", svg: '<svg viewBox="0 0 24 24" fill="currentColor"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm0-14c-3.31 0-6 2.69-6 6s2.69 6 6 6 6-2.69 6-6-2.69-6-6-6zm0 10c-2.21 0-4-1.79-4-4s1.79-4 4-4 4 1.79 4 4-1.79 4-4 4z"/></svg>' },
      { key: "toolbox.categories.communication", svg: '<svg viewBox="0 0 24 24" fill="currentColor"><path d="M1 9l2 2c4.97-4.97 13.03-4.97 18 0l2-2C16.93 2.93 7.08 2.93 1 9zm8 8l3 3 3-3c-1.65-1.66-4.34-1.66-6 0zm-4-4l2 2c2.76-2.76 7.24-2.76 10 0l2-2C15.14 9.14 8.87 9.14 5 13z"/></svg>' },
      { name: "Zvuk", svg: '<svg viewBox="0 0 24 24" fill="currentColor"><path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"/></svg>' },
      { key: "toolbox.categories.filesystem", svg: '<svg viewBox="0 0 24 24" fill="currentColor"><path d="M10 4H4c-1.1 0-1.99.9-1.99 2L2 18c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V8c0-1.1-.9-2-2-2h-8l-2-2z"/></svg>' },
      { key: "toolbox.categories.picoed", svg: '<svg viewBox="0 0 24 24" fill="currentColor"><path d="M15 7.5V2H9v5.5l3 3 3-3zM7.5 9H2v6h5.5l3-3-3-3zM9 16.5V22h6v-5.5l-3-3-3 3zM16.5 9l-3 3 3 3H22V9h-5.5z"/></svg>' }
    ];

    const CATEGORY_ICON_BY_KEY = Object.create(null);
    const CATEGORY_ICON_BY_NAME = Object.create(null);
    CATEGORY_ICON_DEFS.forEach((def) => {
      //console.log(def.key + "   " + def.name);
      if (def.key) CATEGORY_ICON_BY_KEY[def.key] = def.svg;
      if (def.name) CATEGORY_ICON_BY_NAME[def.name] = def.svg;
    });

    let toolboxIconLang = null;
    let toolboxIconLookup = null;

    function buildToolboxIconLookup() {
      toolboxIconLookup = Object.create(null);
      Object.keys(CATEGORY_ICON_BY_NAME).forEach((name) => {
        toolboxIconLookup[name] = CATEGORY_ICON_BY_NAME[name];
      });
      if (typeof t !== "function") return;
      Object.keys(CATEGORY_ICON_BY_KEY).forEach((key) => {
        const translated = t(key);
        if (typeof translated === "string" && translated.trim()) {
          toolboxIconLookup[translated.trim()] = CATEGORY_ICON_BY_KEY[key];
        }
      });
    }

    function resolveToolboxIcon(labelText) {
      if (!labelText) return null;
      const normalized = labelText.trim();
      if (!normalized) return null;
      const lang = currentLanguage || document.documentElement.lang || "en";
      if (!toolboxIconLookup || toolboxIconLang !== lang) {
        toolboxIconLang = lang;
        buildToolboxIconLookup();
      }
      return toolboxIconLookup[normalized] || null;
    }

    function refreshToolboxLayout() {
      if (!window.Blockly || typeof Blockly.getMainWorkspace !== "function") return;
      const ws = Blockly.getMainWorkspace();
      if (!ws) return;
      try { if (typeof onresize === "function") onresize(); } catch (_) {}
      try { if (typeof Blockly.svgResize === "function") Blockly.svgResize(ws); } catch (_) {}
    }

    function injectToolboxIcons() {
      /*
      let injected = false;
      const categories = document.querySelectorAll(".blocklyToolboxCategory");
      categories.forEach((cat) => {
        const label = cat.querySelector(".blocklyTreeLabel");
        if (!label) return;
        const categoryName = label.textContent.trim();
        const key = cat.getAttribute("data-i18n-name") || cat.getAttribute("data-i18n");
        const svgIcon = (key && CATEGORY_ICON_BY_KEY[key]) || resolveToolboxIcon(categoryName);
        if (!svgIcon) return;
        if (cat.querySelector(".category-icon")) return;
        const iconSpan = document.createElement("span");
        iconSpan.className = "category-icon";
        iconSpan.innerHTML = svgIcon;
        const rowContent = cat.querySelector(".blocklyTreeRowContentContainer");
        if (rowContent) {
          rowContent.insertBefore(iconSpan, rowContent.firstChild);
          injected = true;
        }
      });
      if (injected) requestAnimationFrame(refreshToolboxLayout);
      */
    }

    function queueToolboxIconInject(delay = 50) {
      if (typeof injectToolboxIcons !== "function") return;
      clearTimeout(window._iconInjectTimer);
      window._iconInjectTimer = setTimeout(injectToolboxIcons, delay);
    }

    window.injectToolboxIcons = injectToolboxIcons;

    setTimeout(() => queueToolboxIconInject(0), 500);
    setTimeout(() => queueToolboxIconInject(0), 1000);
    setTimeout(() => queueToolboxIconInject(0), 2000);

    const toolboxObserver = new MutationObserver(() => {
      queueToolboxIconInject(50);
    });

    function setupToolboxObserver() {
      const toolboxDiv = document.querySelector(".blocklyToolboxDiv");
      if (toolboxDiv) {
        toolboxObserver.observe(toolboxDiv, { childList: true, subtree: true });
      } else {
        setTimeout(setupToolboxObserver, 500);
      }
    }
    setupToolboxObserver();

    // Load a JS file and resolve when it is ready.
    function loadExternalScript(src) {
      if (typeof loadScript === "function") return loadScript(src);
      return new Promise((res, rej) => {
        const s = document.createElement("script");
        s.src = src;
        s.defer = false;
        s.onload = () => res();
        s.onerror = () => rej(new Error("script load failed " + src));
        document.head.appendChild(s);
      });
    }

    // Refresh Blockly workspace text after a language change.
    function refreshBlocklyLocale() {
      if (!window.Blockly || typeof Blockly.getMainWorkspace !== "function") return;
      const ws = Blockly.getMainWorkspace();
      if (!ws) return;
      const localizedToolbox = buildToolboxXmlForLocale();
      if (localizedToolbox) applyToolboxXml(localizedToolbox);
      try { if (window.demoWorkspace) { onresize(); Blockly.svgResize(demoWorkspace); } } catch (_) {}
    }

    function rebuildBlocklyWorkspaceForLocale() {
      if (!window.Blockly || !window.demoWorkspace) return;
      try {
        const xml = Blockly.Xml.workspaceToDom(demoWorkspace);
        Blockly.Events.disable();
        demoWorkspace.clear();
        Blockly.Xml.domToWorkspace(xml, demoWorkspace);
      } catch (e) {
        console.warn("Blockly workspace rebuild failed:", e);
      } finally {
        try { Blockly.Events.enable(); } catch (_) {}
      }
    }

    // Load Blockly language and refresh the toolbox text.
    async function setBlocklyLanguage(lang) {
      const normalized = normalizeLanguage(lang);
      const candidates = [normalized];
      if (normalized !== BLOCKLY_LANG_FALLBACK) candidates.push(BLOCKLY_LANG_FALLBACK);

      for (const candidate of candidates) {
        if (candidate === currentBlocklyLanguage) {
          pendingBlocklyLocaleRefresh = false;
          return true;
        }

        const src = resolveBlocklyLangUrl(candidate);
        try {
          await loadExternalScript(src);
          currentBlocklyLanguage = candidate;
          pendingBlocklyLocaleRefresh = true;
          return true;
        } catch (e) {
          if (candidate === normalized && normalized !== BLOCKLY_LANG_FALLBACK) {
            console.warn(`Blockly locale '${normalized}' not available, falling back to '${BLOCKLY_LANG_FALLBACK}'.`, e);
          }
        }
      }

      return false;
    }

    // Read the saved UI language from localStorage.
    function getStoredLanguage() {
      try {
        const saved = localStorage.getItem("userSettings");
        const data = saved ? JSON.parse(saved) : {};
        return data.language;
      } catch (e) {
        return null;
      }
    }

    // Save the chosen language in localStorage.
    function persistLanguage(lang) {
      try {
        const saved = localStorage.getItem("userSettings");
        const data = userSettings ? userSettings : (saved ? JSON.parse(saved) : {});
        data.language = lang;
        localStorage.setItem("userSettings", JSON.stringify(data));
        userSettings = data;
      } catch (e) {
        console.warn("Language persist failed:", e);
      }
    }

    function getLanguageParam() {
      try {
        const params = new URL(window.location.href).searchParams;
        return params.get("lang") || params.get("language");
      } catch (e) {
        return null;
      }
    }

    // Pick the best language from URL, saved settings, or browser settings.
    function detectLanguage() {
      return normalizeLanguage(getLanguageParam() || getStoredLanguage() || navigator.language || navigator.userLanguage);
    }

    // Read a deep value like "menu.saveFile" from an object.
    function getValueByPath(obj, key) {
      if (!obj || !key) return null;
      const parts = key.split(".");
      let cur = obj;
      for (const part of parts) {
        if (!cur || typeof cur !== "object" || !(part in cur)) return null;
        cur = cur[part];
      }
      return cur;
    }

    // Replace {name} placeholders in a text string.
    function formatMessage(template, vars) {
      if (!vars) return template;
      // Replace all placeholders with values.
      return Object.keys(vars).reduce((out, key) => {
        const value = vars[key];
        return out.replace(new RegExp(`\\{${key}\\}`, "g"), value);
      }, template);
    }

    // Get a translated string and apply variables if needed.
    function t(key, vars) {
      const value = getValueByPath(activeLanguagePack, key);
      const resolved = (typeof value === "string") ? value : key;
      return formatMessage(String(resolved), vars);
    }

    // Load a language pack JSON file.
    async function loadLanguagePack(lang) {
      const res = await fetch(resolveLangUrl(lang), { cache: "no-store" });
      if (!res.ok) throw new Error(`HTTP ${res.status}`);
      const remote = await res.json();
      if (!remote || typeof remote !== "object") {
        throw new Error("Invalid language pack.");
      }
      return remote;
    }

    // Apply translations to all elements under a root node.
    function applyTranslations(root = document) {
      // Apply plain text replacements.
      root.querySelectorAll("[data-i18n]").forEach((el) => {
        el.textContent = t(el.dataset.i18n);
      });
      // Apply translated title attributes.
      root.querySelectorAll("[data-i18n-title]").forEach((el) => {
        el.setAttribute("title", t(el.dataset.i18nTitle));
      });
      // Apply translated alt attributes.
      root.querySelectorAll("[data-i18n-alt]").forEach((el) => {
        el.setAttribute("alt", t(el.dataset.i18nAlt));
      });
      // Apply translated placeholders.
      root.querySelectorAll("[data-i18n-placeholder]").forEach((el) => {
        el.setAttribute("placeholder", t(el.dataset.i18nPlaceholder));
      });
      // Apply translated input values, but only when safe to replace.
      root.querySelectorAll("[data-i18n-value]").forEach((el) => {
        const key = el.dataset.i18nValue;
        const next = t(key);
        const defaultValue = el.getAttribute("value");
        if (el.value === "" || el.value === el.dataset.i18nLastValue || (defaultValue !== null && el.value === defaultValue)) {
          el.value = next;
          el.dataset.i18nLastValue = next;
        }
      });
      // Apply translated aria-label for accessibility.
      root.querySelectorAll("[data-i18n-aria-label]").forEach((el) => {
        el.setAttribute("aria-label", t(el.dataset.i18nAriaLabel));
      });
      // Apply translated name attributes (used by Blockly).
      root.querySelectorAll("[data-i18n-name]").forEach((el) => {
        el.setAttribute("name", t(el.dataset.i18nName));
      });
    }

    // Load packs, update UI text, and save the choice if needed.
    async function setLanguage(lang, opts = {}) {
      const normalized = normalizeLanguage(lang);
      const languagePackPromise = loadLanguagePack(normalized);
      blocklyLanguageReady = setBlocklyLanguage(normalized);
      try {
        activeLanguagePack = await languagePackPromise;
        currentLanguage = normalized;
      } catch (e) {
        console.error("Language pack load failed:", e);
        return;
      }
      document.documentElement.lang = normalized;
      applyTranslations();
      loadChangelog(normalized);
      try { if (typeof updateSaveButtonLabel === "function") updateSaveButtonLabel(); } catch (_) {}
      try { if (typeof renderTabs === "function") renderTabs(); } catch (_) {}
      try { if (typeof updateMoreMenuLabels === "function") updateMoreMenuLabels(); } catch (_) {}
      const selector = document.getElementById("languageSelect");
      if (selector) selector.value = normalized;
      await blocklyLanguageReady;
      refreshBlocklyLocale();
      if (pendingBlocklyLocaleRefresh) {
        rebuildBlocklyWorkspaceForLocale();
        pendingBlocklyLocaleRefresh = false;
      }
      if (opts.persist !== false) persistLanguage(normalized);
    }

    // Connect the language dropdown to the setLanguage action.
    function initLanguageSelector() {
      const selector = document.getElementById("languageSelect");
      if (!selector) return;
      selector.value = currentLanguage;
      // Apply a new language when the user changes the selector.
      selector.addEventListener("change", () => {
        setLanguage(selector.value).catch(() => {});
        if (typeof showDropdown === "function") {
          setTimeout(showDropdown, 150);
        }
      });
    }

    // Initialize i18n on startup.
    function initI18n() {
      const initial = detectLanguage();
      setLanguage(initial, { persist: false }).catch(() => {});
      initLanguageSelector();
    }

    window.__espideI18n = { t, setLanguage, applyTranslations, get language() { return currentLanguage; } };

    // Show or hide BLE button based on processor support.
    function updateBleVisibility(proc) {
      const btn = document.getElementById('BLE_SerialConnectButton');
      if (!btn) return;
      const supportsBle = !!(BOARD_CAPS[proc] && BOARD_CAPS[proc].ble);
      btn.style.display = supportsBle ? "block" : "none";
    }

    // Theme settings and helpers.
    const THEME_LIGHT = "light";
    const THEME_DARK = "dark";
    let currentTheme = THEME_LIGHT;
    let loadingHidden = false;

    // Normalize theme string to "light" or "dark".
    function normalizeTheme(theme) {
      return theme === THEME_DARK ? THEME_DARK : THEME_LIGHT;
    }

    // Read the stored theme from localStorage.
    function getStoredTheme() {
      try {
        const saved = JSON.parse(localStorage.getItem("userSettings") || "{}");
        return normalizeTheme(saved.theme);
      } catch (e) {
        return THEME_LIGHT;
      }
    }

    // Convert asset path to the dark variant (dark_*).
    function getDarkAsset(path) {
      if (!path) return path;
      const parts = path.split('/');
      const file = parts.pop();
      if (file && file.startsWith('dark_')) return path;
      parts.push('dark_' + file);
      return parts.join('/');
    }

    // Get the correct asset path for the active theme.
    function getThemedAsset(path, themeOverride) {
      const theme = themeOverride || currentTheme;
      return theme === THEME_DARK ? getDarkAsset(path) : path;
    }

    // Update all theme-aware images and backgrounds.
    function applyThemedAssets(theme) {
      const resolved = normalizeTheme(theme);
      document.querySelectorAll('[data-theme-src]').forEach((img) => {
        const base = img.getAttribute('data-theme-src');
        if (!base) return;
        img.setAttribute('src', resolved === THEME_DARK ? getDarkAsset(base) : base);
      });
      document.querySelectorAll('[data-theme-bg]').forEach((el) => {
        const base = el.getAttribute('data-theme-bg');
        if (!base) return;
        const themed = resolved === THEME_DARK ? getDarkAsset(base) : base;
        el.style.backgroundImage = `url('${themed}')`;
      });
    }

    // Save the chosen theme in localStorage.
    function persistTheme(theme) {
      try {
        const saved = localStorage.getItem("userSettings");
        const data = userSettings ? userSettings : (saved ? JSON.parse(saved) : {});
        data.theme = theme;
        localStorage.setItem("userSettings", JSON.stringify(data));
        userSettings = data;
      } catch (e) {
        console.warn("Theme persist failed:", e);
      }
    }

    // Update the browser theme color meta tag.
    function updateMetaThemeColor() {
      const meta = document.querySelector('meta[name="theme-color"]');
      if (!meta) return;
      const cssValue = getComputedStyle(document.documentElement)
        .getPropertyValue('--theme-color')
        .trim();
      meta.setAttribute('content', cssValue || (currentTheme === THEME_DARK ? '#0b0f14' : '#f6f6f6'));
    }

    // Update the ACE editor theme to match the UI.
    function updateAceTheme(theme) {
      const aceTheme = theme === THEME_DARK ? "ace/theme/espide_dark" : "ace/theme/chrome";
      try { if (window.editor) editor.setTheme(aceTheme); } catch (_) {}
      try { if (window.aceText) aceText.setTheme(aceTheme); } catch (_) {}
    }

    // Update the terminal theme colors.
    function updateTerminalTheme(theme) {
      if (!window.term || typeof term.setOption !== 'function') return;
      if (theme === THEME_DARK) {
        term.setOption('theme', {
          background: '#0b0d10',
          foreground: '#e6edf3',
          cursor: '#e6edf3',
          selection: '#1e2632'
        });
      } else {
        term.setOption('theme', {
          background: '#000000',
          foreground: '#ffffff',
          cursor: '#ffffff',
          selection: '#1e2632'
        });
      }
    }

    // Apply the theme across the UI and store it if needed.
    function setTheme(theme, opts) {
      const next = normalizeTheme(theme);
      currentTheme = next;
      document.documentElement.classList.toggle('theme-dark', next === THEME_DARK);
      applyThemedAssets(next);
      try { refreshConnectionImages(); } catch (_) {}
      updateAceTheme(next);
      updateTerminalTheme(next);
      updateMetaThemeColor();
      const toggle = document.getElementById('themeToggle');
      if (toggle) toggle.checked = next === THEME_DARK;
      if (!opts || opts.persist !== false) persistTheme(next);
    }

    // Hook the theme toggle switch to the theme logic.
    function initThemeToggle() {
      const toggle = document.getElementById('themeToggle');
      if (!toggle) return;
      toggle.checked = currentTheme === THEME_DARK;
      toggle.addEventListener('change', () => {
        setTheme(toggle.checked ? THEME_DARK : THEME_LIGHT);
        if (typeof showDropdown === 'function') {
          setTimeout(showDropdown, 150);
        }
      });
    }

    // Hide the loading screen once the UI is ready.
    function hideLoadingScreen() {
      if (loadingHidden) return;
      const screen = document.getElementById('loading_screen');
      if (!screen) return;
      loadingHidden = true;
      screen.classList.add('loading-hidden');
      setTimeout(() => {
        if (screen && screen.parentNode) screen.parentNode.removeChild(screen);
      }, 450);
    }

    currentTheme = getStoredTheme();
    document.documentElement.classList.toggle('theme-dark', currentTheme === THEME_DARK);
    // Initialize theme and language after the DOM is ready.
    document.addEventListener('DOMContentLoaded', () => {
      setTheme(currentTheme, { persist: false });
      initThemeToggle();
      initI18n();
    });




    // Patch SweetAlert so dialogs do not break the layout.
    (function () {
      const origFire = Swal.fire.bind(Swal);

      // Normalize old-style arguments into an options object.
      function normalizeArgs(a, b, c) {
        // Support old Swal.fire('Title', 'Text', 'error') calls.
        if (typeof a === 'object' && a !== null) return a;
        const o = {};
        if (typeof a === 'string') o.title = a;
        if (typeof b === 'string') o.text  = b;
        if (typeof c === 'string') o.icon  = c;
        return o;
      }

      // Wrap Swal.fire to apply safe defaults every time.
      Swal.fire = function (a, b, c) {
        const user = normalizeArgs(a, b, c);

        // Safe defaults to avoid layout issues.
        const SAFE_DEFAULTS = {
          target: '#swal-root',     // Render into our root.
          backdrop: false,          // No global dim (can break layout).
          heightAuto: false,        // Stop SweetAlert2 from resizing <body>.
          scrollbarPadding: false,  // Avoid scrollbar shift.
          allowOutsideClick: false, // Keep modal stable on outside click.
          returnFocus: false,       // Avoid focus jump on close.
          didOpen: () => {
            // Clean up any stray classes.
            document.documentElement.classList.remove('swal2-shown');
            document.body.classList.remove('swal2-shown', 'swal2-height-auto');
          },
          didClose: () => {
            // Refresh UI after close (ACE/Blockly may need redraw).
            requestAnimationFrame(() => {
              try { if (window.aceText) aceText.resize(); } catch(_) {}
              try { if (window.demoWorkspace) { onresize(); Blockly.svgResize(demoWorkspace); } } catch(_) {}
            });
          }
        };

        // Merge, but keep SAFE_DEFAULTS on top.
        const merged = Object.assign({}, SAFE_DEFAULTS, user);
        return origFire(merged);
      };
    })();





    // Ask the user for text input using the best available UI.
    function askText(title, defValue = '') {
      return new Promise((resolve) => {
        // custom-dialog.js wires Blockly.prompt to Swal text input.
        if (window.Blockly && typeof Blockly.prompt === 'function') {
          Blockly.prompt(title, defValue, (val) => resolve(val));
        } else if (window.dlg && typeof window.dlg.message === 'function') {
          // Fallback: text input via Swal.
          Swal.fire({
            input: 'text',
            inputValue: defValue || '',
            title,
            showCancelButton: true,
            confirmButtonText: t('actions.ok'),
            cancelButtonText: t('actions.cancel')
          }).then(r => resolve(r.isConfirmed ? r.value : null));
        } else {
          // Last-resort fallback: native prompt.
          const v = window.prompt(title, defValue);
          resolve(v === null ? null : v);
        }
      });
    }


    // Validate a file name and return a translated error string.
    function validateFileName(name, indexToIgnore = -1) {
      const trimmed = (name || '').trim();
      if (!trimmed) return t('validation.fileNameEmpty');
      // "/" is allowed here.
      if (/[\\:*?"<>|]/.test(trimmed)) return t('validation.fileNameInvalidChars');
      const exists = (textProject.files || []).some((f, i) => i !== indexToIgnore && f && f.name === trimmed);
      if (exists) return t('validation.fileNameExists');
      return null;
    }








    // Small HTML escape helper for safe <pre> output.
    function _esc(s){return s.replace(/[&<>\"']/g, c=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;' }[c]));}

    // Show the changelog in a modal dialog.
    async function showChangelog(){
      await loadChangelog(currentLanguage || document.documentElement.lang || "en");
      const html = '<pre style="text-align:left;white-space:pre-wrap;margin:0;">' + _esc(ESPIDE_CHANGELOG) + '</pre>';
      Swal.fire({
        title: `ESP IDE \n ${ESPIDE_VERSION}`,
        html,
        width: 800,
        confirmButtonText: t('dialogs.changelogClose'),
        allowOutsideClick: true
      });
    }

    // Write the version into the menu once the DOM is ready.
    document.addEventListener('DOMContentLoaded', ()=>{
      updateVersionText();
    });





    // === Extensions: constants and helpers =============================
    const EXT_BLOB_BEGIN = "<!--ESPIDE_EXTENSIONS_BEGIN-->";
    const EXT_BLOB_END   = "<!--ESPIDE_EXTENSIONS_END-->";

    // Convert UTF-8 text to base64.
    function utf8_to_b64(str){ return btoa(unescape(encodeURIComponent(str))); }
    // Convert base64 back to UTF-8 text.
    function b64_to_utf8(str){ return decodeURIComponent(escape(atob(str))); }



    // Find block types used in the project XML.
    function collectBlockTypesFromXml(xmlText){
      const set = new Set();
      const re = /<block[^>]*\stype="([^"]+)"/g;
      let m;
      while ((m = re.exec(xmlText))){ set.add(m[1]); }
      return set;
    }

    // Find block types defined inside an extension JS file.
    function collectDefinedTypesFromExtJs(js){
      const set = new Set();
      if (!js || typeof js !== "string") return set;

      // 1) Classic definitions: Blockly.Blocks['type']
      const re1 = /Blockly\.Blocks\[['"]([^'"]+)['"]\]/gm;
      let m;
      while ((m = re1.exec(js))) { set.add(m[1]); }

      // 2) Generators: Blockly.Python['type'] (includes MicroPython/Micropython)
      const re2 = /Blockly\.(?:Python|MicroPython|Micropython)\[['"]([^'"]+)['"]\]/gm;
      while ((m = re2.exec(js))) { set.add(m[1]); }

      // 3) JSON block definitions: type: 'xxx'
      //    Heuristic: may add a few false positives.
      const re3 = /type\s*:\s*['"]([^'"]+)['"]/gm;
      while ((m = re3.exec(js))) { set.add(m[1]); }

      return set;
    }


    // From all extensions, keep only those used by the project.
    function pickUsedExtensions(xmlText){
      const usedTypes = collectBlockTypesFromXml(xmlText);
      const picked = [];
      const src = (typeof extensions === "object" && extensions) ? extensions : {};

      Object.keys(src).forEach(name=>{
        const ext = src[name] || {};
        if (!ext.js) return;
        const types = collectDefinedTypesFromExtJs(ext.js);
        for (const t of types){
          if (usedTypes.has(t)){
            picked.push({name, js: ext.js || "", xml: ext.xml || "", enabled: ext.enabled!==false});
            return;
          }
        }
      });

      if (picked.length===0){
        Object.keys(src).forEach(name=>{
          const ext = src[name];
          if (ext?.enabled) picked.push({name, js: ext.js||"", xml: ext.xml||"", enabled:true});
        });
      }
      return picked;
    }


    // Extract the payload from comment and return {payload, strippedText}.
    function peelExtensionsComment(fullText){
      const allBeg = [...fullText.matchAll(/<!--ESPIDE_EXTENSIONS_BEGIN-->/g)].map(m=>m.index);
      const allEnd = [...fullText.matchAll(/<!--ESPIDE_EXTENSIONS_END-->/g)].map(m=>m.index);
      if (!allBeg.length || !allEnd.length) return {payload:null, strippedText: fullText};

      const i1 = allBeg[allBeg.length - 1];
      const i2 = allEnd.find(i => i > i1);
      if (i2 == null) return {payload:null, strippedText: fullText};

      const before = fullText.slice(0, i1);
      const inside = fullText.slice(i1 + "<!--ESPIDE_EXTENSIONS_BEGIN-->".length, i2).trim();
      const after  = fullText.slice(i2 + "<!--ESPIDE_EXTENSIONS_END-->".length);
      let payload = null;
      try {
        const json = b64_to_utf8(inside);
        payload = JSON.parse(json);
      } catch(e){
        console.warn("Decode EXT payload fail:", e);
      }
      return {payload, strippedText: before + after};
    }


    // Merge extensions from payload into the current set.
    function mergeAndIntegrateExtensionsFromPayload(payload){
      if (!payload || !Array.isArray(payload.extensions)) return;
      payload.extensions.forEach(e=>{
        if (!e || !e.name) return;
        extensions[e.name] = { js: e.js||"", xml: e.xml||"", enabled: e.enabled!==false };
      });
      // Save and integrate via existing logic.
      applyExtensionSelection(); // Saves extensions + new_blocks_js/xml and calls integrateExtensions.
    }
    // ===================================================================

    // Insert payload comment inside <xml>...</xml> before the closing tag.
    function injectExtensionsIntoXml(xmlText, payloadB64){
      const insert = `\n  ${EXT_BLOB_BEGIN}\n${payloadB64}\n${EXT_BLOB_END}\n`;
      const idx = xmlText.lastIndexOf('</xml>');
      if (idx !== -1) {
        // Standard case: root <xml>...</xml> is present.
        return xmlText.slice(0, idx) + insert + xmlText.slice(idx);
      }
      // Fallback: missing root <xml>...</xml> (rare, but be safe).
      return '<xml>\n' + xmlText + '\n' + insert + '</xml>\n';
    }





    // Load saved extensions on startup in a safe way.
    function safeLoadExtensionsOnStartup() {
      try {
        // 1) Try merged sources first (fast).
        let js = localStorage.getItem("new_blocks_js")  || "";
        let xml= localStorage.getItem("new_blocks_xml") || "";

        // 2) If empty, rebuild from detailed records.
        if (!(js || xml) && Object.keys(extensions).length) {
          Object.values(extensions).forEach(e=>{
            if (e.enabled !== false) {          // default = enabled
              js  += e.js  || "";
              xml += e.xml || "";
            }
          });
        }

        // 3) if there is something to load, integrate it
        if (js || xml) integrateExtensions(js, xml);
      } catch (e) {
        console.error("Auto-load EXT error:", e);
        Swal.fire(t('errors.title'), t('errors.extensionsLoad', { error: e.message }), "error");
      }
    }


    // Build the extensions list UI from current data.
    function refreshExtList(){
      const list   = document.getElementById("ext_list");
      list.innerHTML = "";

      Object.keys(extensions).forEach(name=>{
        const row      = document.createElement("div"); row.className="ext_row";
        const chk      = document.createElement("input"); chk.type="checkbox";
        chk.checked    = extensions[name].enabled;
        chk.onchange   = ()=>extensions[name].enabled = chk.checked;

        const lbl      = document.createElement("label"); lbl.textContent = name;
        const del      = document.createElement("button"); del.textContent="✖";
        del.className  = "ext_btn";
        del.onclick    = ()=>{ delete extensions[name]; refreshExtList(); };

        row.append(chk,lbl,del);
        list.appendChild(row);
      });
    }

    // Open the extensions dialog and refresh its list.
    function openExtensionsDialog(){
      refreshExtList();
      document.getElementById("extensions_dialog").style.display="block";
    }

    // Close the extensions dialog.
    function closeExtensionsDialog(){
      document.getElementById("extensions_dialog").style.display="none";
    }


    // Apply saved category filters to the toolbox.
    function applyStoredFilter() {
      if (!originalToolboxXML) return;
      const localized = buildToolboxXmlForLocale();
      applyToolboxXml(localized);
    }

    // Save selected extensions and rebuild the toolbox.
    function applyExtensionSelection(){
      // Aggregate sources from enabled extensions only.
      let agg_js="", agg_xml="";
      Object.values(extensions).forEach(ext=>{
        if(ext.enabled){ agg_js  += ext.js;  agg_xml += ext.xml; }
      });
      // Persist to storage.
      localStorage.setItem("extensions", JSON.stringify(extensions));
      localStorage.setItem("new_blocks_js",  agg_js);
      localStorage.setItem("new_blocks_xml", agg_xml);
      integrateExtensions(agg_js, agg_xml);
      closeExtensionsDialog();
    }



    // Merge extension JS and XML into the current Blockly setup.
    function integrateExtensions(jsSrc = "", xmlSrc = "") {
      /* 1) JS part ------------------------------------------------- */
      if (jsSrc.trim()) {
        try {
		      //console.log(jsSrc);
          eval(jsSrc);
        } catch (e) {
          console.error("Ext-JS runtime error:", e);
          Swal.fire(t('errors.extensionScriptTitle'), e.message, "error");
          return;                               // Stop to keep the toolbox intact.
        }
      }

      /* 2) XML/toolbox part --------------------------------------- */
      if (!originalToolboxXML) return;          // Workspace not ready yet.

      // Strip the <xml> wrapper.
      let stripped = (xmlSrc || "")
                     .replace(/^<xml[^>]*>/, "")
                     .replace(/<\/xml>\s*$/, "");

      addons_toolbox = stripped;                // Keep for filters.
      try {
        const localized = buildToolboxXmlForLocale();
        applyToolboxXml(localized);
      } catch (e) {
        console.error("Ext-XML error:", e);
        Swal.fire(t('errors.extensionToolboxTitle'), e.message, "error");
        return;
      }
    }







    // Return the toolbox filename for the selected processor.
    function getToolboxFilename(processor) {
      return TOOLBOX_MAP[processor] || "toolbox_ESP32.xml";
    }


    // Load a toolbox XML file by name and handle offline cache.
    async function fetchToolboxFile(filename) {
      const url = new URL(filename, location.href).toString();
      // 1) Try the network first.
      try {
        const res = await fetch(url, { cache: 'no-store' });
        if (!res.ok) throw new Error('HTTP ' + res.status);
        const txt = await res.text();
        // Quick check: it must look like <xml ...>.
        if (/^\s*<!DOCTYPE html>/i.test(txt) || !/\<xml[\s>]/i.test(txt)) {
          throw new Error('Unexpected content (not XML)');
        }
        return txt;
      } catch (netErr) {
        // 2) Offline fallback from the Cache API.
        try {
          const keys = await caches.keys();
          for (const k of keys) {
            const c = await caches.open(k);
            const r = await c.match(url, { ignoreSearch: true });
            if (r) {
              const txt = await r.text();
              if (/\<xml[\s>]/i.test(txt)) return txt;
            }
          }
        } catch (_) {}
        // 3) Bubble up the error (UI already handles it).
        throw netErr;
      }
    }


    // Remove toolbox categories based on user filters.
    function filterToolboxWithFilters(xmlString, filters) {
      try {
        filters = filters || {};
        var parser = new DOMParser();
        var xmlDoc = parser.parseFromString(xmlString, "text/xml");
        var categories = xmlDoc.getElementsByTagName("category");
        // Walk categories from the end to remove nodes safely.
        for (var i = categories.length - 1; i >= 0; i--) {
          var cat = categories[i];
          var catName = cat.getAttribute("name");
          if (filters[catName]) {
            if (!filters[catName].enabled) {
              cat.parentNode.removeChild(cat);
              continue;
            }
            if (filters[catName].subcategories) {
              var children = Array.from(cat.childNodes).filter(node => node.nodeType === Node.ELEMENT_NODE);
              var labelIndex = 0;
              for (var idx = 0; idx < children.length; idx++) {
                var node = children[idx];
                if (node.nodeName.toLowerCase() === "label") {
                  var key = catName + "_" + labelIndex;
                  if (!filters[catName].subcategories[key]) {
                    var removalLabel = node;
                    var sibling = removalLabel.nextSibling;
                    removalLabel.parentNode.removeChild(removalLabel);
                    while (sibling) {
                      if (sibling.nodeType === Node.TEXT_NODE && sibling.textContent.trim() === "") {
                        var temp = sibling;
                        sibling = sibling.nextSibling;
                        temp.parentNode.removeChild(temp);
                        continue;
                      }
                      if (sibling.nodeType === Node.ELEMENT_NODE && sibling.nodeName.toLowerCase() === "block") {
                        var temp = sibling;
                        sibling = sibling.nextSibling;
                        temp.parentNode.removeChild(temp);
                        continue;
                      }
                      if (sibling.nodeType === Node.ELEMENT_NODE && sibling.nodeName.toLowerCase() === "label") {
                        break;
                      }
                      break;
                    }
                  }
                  labelIndex++;
                }
              }
            }
          }
        }
        // Drop empty categories (no blocks/labels),
        // unless they have a custom attribute.
        var updatedCategories = xmlDoc.getElementsByTagName("category");
        for (var i = updatedCategories.length - 1; i >= 0; i--) {
          var cat = updatedCategories[i];
          // Skip custom categories.
          if (cat.hasAttribute("custom")) continue;
          var content = Array.from(cat.childNodes).filter(node => {
            return node.nodeType === Node.ELEMENT_NODE &&
                   (node.nodeName.toLowerCase() === "block" || node.nodeName.toLowerCase() === "label");
          });
          if (content.length === 0) {
            cat.parentNode.removeChild(cat);
          }
        }
        var serializer = new XMLSerializer();
        return serializer.serializeToString(xmlDoc);
      } catch (e) {
        console.error("Toolbox filtering failed:", e);
        return xmlString;
      }
    }





    // Show the category filter dialog and collect user choices.
    async function showCategoryFilterDialog(toolboxXMLString) {
      var parser = new DOMParser();
      var xmlDoc = parser.parseFromString(toolboxXMLString, "text/xml");
      var categoryNodes = xmlDoc.getElementsByTagName("category");
      var formHtml = "";
      function resolveDisplayText(node, fallback, kind) {
        if (!node) return fallback;
        const key =
          node.getAttribute("data-i18n") ||
          node.getAttribute("i18n") ||
          (kind === "name"
            ? node.getAttribute("data-i18n-name") || node.getAttribute("i18n-name")
            : node.getAttribute("data-i18n-text") || node.getAttribute("i18n-text"));
        return key ? t(key) : fallback;
      }
      for (var i = 0; i < categoryNodes.length; i++) {
        var catName = categoryNodes[i].getAttribute("name");
        var catLabel = resolveDisplayText(categoryNodes[i], catName, "name");
        // Read category color (fallback when missing).
        var catColor = categoryNodes[i].getAttribute("colour") || "#ffffff";
        // Category container with color and left alignment.
        formHtml += '<div style="background-color: ' + catColor + '; padding: 6px; margin-bottom: 5px; text-align: left; border-radius: 5px;">';
        formHtml += '<h3 style="font-size: 19px; margin: 0px 0px 2px 6px; color: #ffffff; text-shadow: 0px 0px 3px #00000080;">' + catLabel + '</h3>';
        var hasSubcats = false;
        var childNodes = categoryNodes[i].childNodes;
        var subcatIndex = 0;
        // Walk subcategories (<label> elements) inside the category.
        for (var j = 0; j < childNodes.length; j++) {
          if (childNodes[j].nodeName.toLowerCase() === "label") {
            hasSubcats = true;
            var labelText = childNodes[j].getAttribute("text");
            var labelDisplay = resolveDisplayText(childNodes[j], labelText, "text");
            var checkboxName = catName + "_" + subcatIndex;
            // Use stored state if present; otherwise default to checked.
            var subcatChecked = true;
            if (userSettings && userSettings.filters && userSettings.filters[catName] &&
                userSettings.filters[catName].subcategories &&
                userSettings.filters[catName].subcategories.hasOwnProperty(checkboxName)) {
              subcatChecked = userSettings.filters[catName].subcategories[checkboxName];
            }
            formHtml += '<label style="display: inline-block; margin-right: 10px; vertical-align: middle; color: #ffffff; text-shadow: 1px 1px 3px #000000b0;">';
            formHtml += '<input type="checkbox" name="' + checkboxName + '" ' + (subcatChecked ? 'checked' : '') + ' style="vertical-align: middle; margin-right: 5px; width: 24px;height: 18px; display: inline-block;">';
            formHtml += labelDisplay;
            formHtml += '</label><br>';
            subcatIndex++;
          }
        }
        // If no subcategories exist, offer a whole-category toggle.
        if (!hasSubcats) {
          var catChecked = true;
          if (userSettings && userSettings.filters && userSettings.filters.hasOwnProperty(catName) &&
              userSettings.filters[catName].hasOwnProperty("enabled")) {
            catChecked = userSettings.filters[catName].enabled;
          }
          formHtml += '<label style="display: inline-block; margin-right: 10px; vertical-align: middle; color: #ffffff; text-shadow: 1px 1px 3px #000000b0;">';
          formHtml += '<input type="checkbox" name="' + catName + '" ' + (catChecked ? 'checked' : '') + ' style="vertical-align: middle; margin-right: 5px; width: 24px;height: 18px; display: inline-block;">';
          formHtml += t('blocks.wholeCategory', { name: catLabel });
          formHtml += '</label><br>';
        }
        formHtml += '</div>';
      }

      return Swal.fire({
        title: t('dialogs.blockVisibilityTitle'),
        html: formHtml,
        focusConfirm: false,
        showCancelButton: false,
        preConfirm: () => {
          var filters = {};
          var inputs = Swal.getPopup().querySelectorAll('input[type=checkbox]');
          inputs.forEach(function(chk) {
            var name = chk.name;
            var checked = chk.checked;
            if (name.indexOf("_") !== -1) {
              var parts = name.split("_");
              var cat = parts[0];
              if (!filters[cat]) {
                filters[cat] = { enabled: true, subcategories: {} };
              }
              filters[cat].subcategories[name] = checked;
            } else {
              filters[name] = { enabled: checked };
            }
          });
          return filters;
        },
        width: '550px',
        footer: '<div style="padding-bottom: 4px;"></div>'
      });
    }


    // Show the processor selection dialog with a default value.
    async function showProcessorDialog() {
      var defaultProcessor = "ESP32";
      //if (userSettings && userSettings.processor) {
      //  defaultProcessor = userSettings.processor;
      //}
      return Swal.fire({
        title: t('dialogs.selectProcessorTitle'),
        html:
          '<select id="swal-processor" class="swal2-input">' +
            '<option value="ESP32">ESP32</option>' +
            '<option value="ESP32C3">ESP32C3</option>' +
            '<option value="ESP32S3">ESP32S3</option>' +
            '<option value="ESP8266">ESP8266</option>' +
            '<option value="RP2040">RP2040</option>' +
            '<option value="RP2040_Picoed">RP2040 Pico:ed</option>' +
			'<option value="OMG_ESPBit">OMG ESP:Bit</option>' +
          '</select>',
        focusConfirm: false,
        allowOutsideClick: false,
        allowEscapeKey: false,
        preConfirm: () => {
          return {
            processor: document.getElementById('swal-processor').value
          }
        },
        didOpen: () => {
          document.getElementById('swal-processor').value = defaultProcessor;
        }
      });
    }




    // Update the processor, reload toolbox, and refresh the workspace.
    async function updateProcessor(newProc) {
      updateBleVisibility(newProc);

      if (newProc === userSettings.processor) return;

      userSettings.processor = newProc;
      localStorage.setItem("userSettings", JSON.stringify(userSettings));

      try {
        toolboxFilename      = getToolboxFilename(newProc);
        const baseXML        = await fetchToolboxFile(toolboxFilename);
        originalToolboxXML   = baseXML;

        const localized = buildToolboxXmlForLocale();
        applyToolboxXml(localized);

        console.log('Processor switched to', newProc);
      } catch (e) {
        console.error('Processor switch failed:', e);
        Swal.fire(
          t('errors.title'),
          t('errors.switchProcessorFailed', { error: e.message }),
          'error'
        );
      }
    }

  </script>




<script>
    // Connect button UI states.
      const STATE = {
        DISCONNECTED: 0,
        DISCONNECTED_HOVER: 1,
        CONNECTED: 2,
        CONNECTED_HOVER: 3,
        ERROR: 4,
        ERROR_HOVER: 5
      };

      let currentState = STATE.DISCONNECTED;

      const images = [
        "img0.gif", // disconnected
        "img1.png", // disconnected hover
        "img2.png", // connected
        "img3.png", // connected hover
        "img4.png", // error
        "img5.png"  // error hover
      ];





    var editor;
    var term;
    var blocklyArea;
    var blocklyDiv;
    var demoWorkspace;
    var code_window_open = false;
    var vibro_time = 100;
    let connectButton;
    let bleConnectButton;
    var toolboxFilename;

    var run_uploaded_code = false;


    // Track whether any code has been uploaded to the device.
    var first_upload = true;


    // Global communication instances.
    let mpSerial;  // instance of MicroPythonSerial


    // Active link and instances.
    let activeLink = 'usb';          // 'usb' | 'ble'
    let mpBLE = null;

    // Unified connection logic.
    const CONNECTED_STATES = new Set([STATE.CONNECTED, STATE.CONNECTED_HOVER]);

    // Check if USB is connected based on port and UI state.
    function isUsbConnected() {
      // Rely on the actual port and UI state.
      const portOk = !!(mpSerial && mpSerial.port);
      const uiOk   = CONNECTED_STATES.has(currentState);
      // Extra safety: check streams when available.
      const streamsOk = portOk && (
        (mpSerial.port.readable || mpSerial.port.writable || typeof mpSerial.isOpen === "function")
      );
      return (portOk && uiOk) || streamsOk;
    }

    // Check if BLE is connected based on link state and UI.
    function isBleConnected() {
      // BLE class exposes .connected; also consider button state.
      const bleOk = !!(mpBLE && mpBLE.connected);
      const uiOk  = typeof bleState !== "undefined" ? CONNECTED_STATES.has(bleState) : true;
      return bleOk && uiOk;
    }

    // Check if any transport is connected.
    function isEditorConnected() {
      return isUsbConnected() || isBleConnected();
    }

    // Decide which link is active, with a safe fallback.
    function getActiveLink() {
      if (activeLink === 'ble' && isBleConnected()) return 'ble';
      if (activeLink === 'usb' && isUsbConnected()) return 'usb';
      // Fallback: infer from actual connection.
      if (isBleConnected()) return 'ble';
      if (isUsbConnected()) return 'usb';
      return 'none';
    }

    // Get the active transport for mp().* calls.
    function getActiveTransport() {
      const link = getActiveLink();
      if (link === 'ble') return mpBLE;
      if (link === 'usb') return mpSerial;
      return null;
    }

    // Alias to get the active transport.
    const mp = () => getActiveTransport();








    // Icon sets for USB and BLE.
    let usbImages = [];
    let bleImages = [];

    // Refresh themed icons and update button images.
    function refreshConnectionImages() {
        usbImages = images.map(n => getThemedAsset("media/usb_" + n));
        bleImages = images.map(n => getThemedAsset("media/ble_" + n));
        if (connectButton) updateButton(currentState);
        if (bleConnectButton) bleUpdateButton(bleState);
    }

    // BLE button state (USB already has currentState/updateButton).
    let bleState = STATE.DISCONNECTED;


    // Update the BLE connect button image.
    function bleUpdateButton(state) {
        bleState = state;
        if (!bleConnectButton || !bleImages.length) return;
        bleConnectButton.style.backgroundImage = `url('${bleImages[state]}')`;
    }

    // Update the USB connect button image.
    function updateButton(state) {
        currentState = state;
        if (!connectButton || !usbImages.length) return;
        connectButton.style.backgroundImage = `url('${usbImages[state]}')`;
    }
    refreshConnectionImages();


    let __connectLock = Promise.resolve();

    // Run a connection action one at a time.
    async function withConnectLock(fn){
      const prev = __connectLock;
      let release;
      __connectLock = new Promise(r => release = r);
      try { await prev; return await fn(); }
      finally { release(); }
    }

    // Ensure only one transport is connected at a time.
    async function ensureExclusive(target){ // 'usb' | 'ble'
      if (target === 'usb' && isBleConnected()){
        try { await mpBLE.disconnect(); } catch(_) {}
        bleUpdateButton(STATE.DISCONNECTED);
        activeLink = 'none';
        await delay(100);
      }
      if (target === 'ble' && isUsbConnected()){
        try { await mpSerial.disconnect(); } catch(_) {}
        updateButton(STATE.DISCONNECTED);
        activeLink = 'none';
        await delay(100);
      }
    }




    // Small delay helper.
    function delay(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }

    // Resize and reposition the Blockly workspace to fit the area.
    function onresize(e) {
      var element = blocklyArea;
      if(element)
      {
          var x = 0;
          var y = 0;
          do {
            x += element.offsetLeft || 0;
            y += element.offsetTop || 0;
            element = element.offsetParent;
          } while (element);
          blocklyDiv.style.left = x + 'px';
          blocklyDiv.style.top = (y + 44) + 'px';
          blocklyDiv.style.width = blocklyArea.offsetWidth + 'px';
          blocklyDiv.style.height = (blocklyArea.offsetHeight - 44) + 'px';
          Blockly.svgResize(demoWorkspace);
      }
    }

















    let AceEditSession = null;
    let AceUndoManager = null;
    let AceUndoManagerCtor = null;

    let textProject = {
      files: [],            // {name, session, dirty}
      activeIndex: -1
    };


    // Project mode flag.
    let projectMode = "blocks"; // "blocks" | "text"

    // Text project and tabs state.
    let aceText = null;

    // Update Save button labels based on current mode.
    function updateSaveButtonLabel(){
      const els = document.querySelectorAll('area[data-role="save"]');
      const isText = (typeof projectMode !== 'undefined' && projectMode === 'text');
      const alt   = isText ? t('actions.saveToDevice') : t('actions.saveToPc');
      const title = isText ? t('actions.saveToDevice') : t('actions.saveToPc');
      els.forEach(el => { el.alt = alt; el.title = title; });
    }

    // Switch between block mode and text mode.
    function switchUITo(mode){
      const blocklyDiv = document.getElementById('blocklyDiv');
      const textShell  = document.getElementById('textShell');

      if (mode === "blocks"){
        // Blocks visible, text hidden.
        blocklyDiv.style.visibility   = "visible";
        blocklyDiv.style.pointerEvents = "auto";
        textShell.style.display = "none";

        projectMode = "blocks";

        requestAnimationFrame(() => {
          void blocklyDiv.offsetHeight; // Force reflow.
          onresize();                   // Recalc metrics.
        });
      } else {
        // Text visible, blocks inactive but still in layout.
        blocklyDiv.style.visibility    = "hidden";
        blocklyDiv.style.pointerEvents = "none";
        textShell.style.display = "block";
        blocklyDiv.style.height = "1px";

        projectMode = "text";

        requestAnimationFrame(() => { try { aceText && aceText.resize(); } catch(e){} });
      }

      try { updateSaveButtonLabel(); } catch(_) {}
      localStorage.setItem("espide.projectMode", mode);
    }

      // Handle the mode toggle after DOM is ready.
      document.addEventListener('DOMContentLoaded', ()=>{
        const rbBlocks = document.getElementById('modeBlocks');
        const rbText   = document.getElementById('modeText');
        if (rbBlocks && rbText){
          rbBlocks.addEventListener('change', ()=>rbBlocks.checked && switchUITo("blocks"));
          rbText  .addEventListener('change', ()=>rbText.checked   && switchUITo("text"));

          // Restore last mode.
          const saved = localStorage.getItem("espide.projectMode");
          if (saved === "text"){ rbText.checked = true; switchUITo("text"); }
          else { rbBlocks.checked = true; switchUITo("blocks"); }
        }
      });

      // Create a new UndoManager or use a safe fallback.
      function newUndoManager(){
          try{
            if (AceUndoManagerCtor) return new AceUndoManagerCtor();
            const umMod = ace.require("ace/undomanager");
            if (umMod && umMod.UndoManager) return new umMod.UndoManager();
          }catch(_){}
          // Fallback shim; should not be needed.
          return {
            undo(){}, redo(){}, hasUndo(){return false;}, hasRedo(){return false;},
            markClean(){}, markDirty(){}, execute(){}
          };
      }


      // Ensure there is at least one default tab.
      function ensureOneDefaultTab(){
          addNewTab(uniqueFileName(t('textProject.newFileBase'), 'py', -1), t('textProject.newFileHint'));
      }

      // Create a new text tab and ACE session.
      function addNewTab(name, content){
          name = uniqueFileName(name.replace(/\.[^\.]+$/, ''), name.split('.').pop() || "py");
          const ses = new AceEditSession(content || "");
          ses.setMode("ace/mode/python");
          ses.setUndoManager(newUndoManager());   // Proper UndoManager.

          // Mark the current tab as dirty on content change.
          ses.on('change', ()=>{
            const i = textProject.activeIndex;
            if (i >= 0) {
              textProject.files[i].dirty = true;
              saveTextProjectToLS();
              renderTabs();
            }
          });

          textProject.files.push({name, session: ses, dirty:false});
          textProject.activeIndex = textProject.files.length - 1;
          if (aceText) aceText.setSession(ses);
          renderTabs();
          saveTextProjectToLS();
      }



      // Activate a tab and switch the ACE session.
      function activateTab(index){
          if (index<0 || index>=textProject.files.length) return;
          textProject.activeIndex = index;
          if (aceText){
            aceText.setSession(textProject.files[index].session);
            aceText.focus(); // ensure Ctrl+Z/Redo targets ACE
          }
          renderTabs();
      }


      // Close a tab and handle unsaved changes.
      function closeTab(index){
          if (index<0 || index>=textProject.files.length) return;
          const f = textProject.files[index];
          if (f.dirty && !confirm(t('dialogs.closeTabConfirm', { name: f.name }))) return;

          textProject.files.splice(index,1);

          if (textProject.files.length === 0){
            textProject.activeIndex = -1;
            ensureOneDefaultTab();
          } else {
            textProject.activeIndex = Math.min(index, textProject.files.length-1);
            aceText && aceText.setSession(textProject.files[textProject.activeIndex].session);
          }
          renderTabs();
          saveTextProjectToLS();
      }

      // Rename a tab with validation and uniqueness checks.
      async function renameTab(index) {
          const cur = textProject.files[index];
          if (!cur) return;

          // 1) Ask the user for the new name.
          let nn = await askText(t('dialogs.renameFileTitle'), cur.name);
          if (nn === null) return;              // user canceled
          nn = nn.trim();

          // 2) Preserve base/ext split logic.
          const p = splitNameExt(nn);
          let candidate = uniqueFileName(p.base, p.ext, index);

          // 3) Validate and retry once if needed.
          let err = validateFileName(candidate, index);
          if (err) {
            // Simple retry: show the error and allow one more attempt
            await Swal.fire({ icon: 'error', title: t('dialogs.renameInvalidTitle'), text: err, confirmButtonText: t('actions.tryAgain') });
            nn = await askText(t('dialogs.renameFileTitle'), candidate);
            if (nn === null) return;
            const p2 = splitNameExt(nn.trim());
            candidate = uniqueFileName(p2.base, p2.ext, index);
            err = validateFileName(candidate, index);
            if (err) {
              await Swal.fire({ icon: 'error', title: t('dialogs.renameFailedTitle'), text: err });
              return;
            }
          }

          // 4) Save and re-render.
          cur.name = candidate;
          renderTabs();
          saveTextProjectToLS();
      }


        // Render the tab strip UI.
        function renderTabs(){
          const host = document.getElementById('tabs');
          host.innerHTML = "";
          textProject.files.forEach((f, i)=>{
            const b = document.createElement('div');
            b.className = "tab-pill";
            if (i===textProject.activeIndex) b.classList.add("is-active");
            b.innerHTML = '<span style="font-family:monospace">' + f.name + (f.dirty ? '*' : '') + '</span>'
              + `<span data-action="rename" title="${t('actions.rename')}" style="opacity:.7; margin-left:6px;">✎</span>`
              + `<span data-action="close" title="${t('actions.close')}" style="opacity:.7;">×</span>`;

            // Handle tab click actions.
            b.addEventListener('click', (ev)=>{
              const action = ev.target && ev.target.getAttribute && ev.target.getAttribute('data-action');
              if (action === "close") { closeTab(i); ev.stopPropagation(); return; }
              if (action === "rename") { renameTab(i); ev.stopPropagation(); return; }
              activateTab(i);
            });
            host.appendChild(b);
          });
        }

        // Wire the New Tab button after the DOM is ready.
        document.addEventListener('DOMContentLoaded', ()=>{
          const btn = document.getElementById('btnNewTab');
          if (btn) btn.addEventListener('click', ()=> addNewTab(uniqueFileName(t('textProject.newFileBase'), "py"), ""));
        });

        // Save text project state to localStorage.
        function saveTextProjectToLS(){
          try {
            const data = {
              files: textProject.files.map(f=>({name:f.name, content:f.session.getValue()})),
              activeIndex: textProject.activeIndex
            };
            localStorage.setItem("espide.textProject", JSON.stringify(data));
          } catch(e){ console.warn(e); }
        }

        // Restore text project state from localStorage.
        function restoreTextProjectFromLS(){
          try {
            const raw = localStorage.getItem("espide.textProject");
            if (!raw) return;
            const data = JSON.parse(raw);

            textProject.files = (data.files||[]).map(x=>{
              const ses = new AceEditSession(x.content || "");
              ses.setMode("ace/mode/python");
              ses.setUndoManager(newUndoManager());   // Important.
              // Mark tabs dirty on change.
              ses.on('change', ()=>{
                const i = textProject.activeIndex;
                if (i >= 0) {
                  textProject.files[i].dirty = true;
                  saveTextProjectToLS();
                  renderTabs();
                }
              });
              return { name:x.name, session: ses, dirty:false };
            });

            textProject.activeIndex = Math.min(
              Math.max(0, data.activeIndex|0),
              Math.max(0, textProject.files.length-1)
            );
          } catch(e){ console.warn(e); }
        }



        // Create a unique file name for the tab list.
        function uniqueFileName(base, ext, ignoreIndex = -1){
          const taken = new Set(textProject.files
            .map((f, idx)=> idx===ignoreIndex ? null : f.name)
            .filter(Boolean));
          let n = 1, name;
          do {
            name = base + n + '.' + ext;
            n++;
          } while (taken.has(name));
          return name;
        }












    // Show a warning message using SweetAlert.
    function show_modal_message(in_txt,text_detail) {
        Swal.fire({
          title: in_txt,
          text: text_detail,
          icon: "warning",
          showConfirmButton: true,
          // SweetAlert2 v11: no deprecated hooks.
          backdrop: false,
          allowOutsideClick: false,
          allowEscapeKey: true,
          allowEnterKey: true
        })
    }






    // Fetch a file and upload it to the device.
    async function sendFileToDevice(fileUrl, targetFolder) {
      // Check device connection.
      if (!isEditorConnected()) {
        //alert("Device not connected!");
        show_modal_message(t('errors.notConnectedTitle'), t('errors.notConnectedBody'));
        return;
      }

      // Return the Promise from fetch.
      return fetch(fileUrl)
        .then(response => {
          if (!response.ok) {
            throw new Error(t('errors.fileLoadFailedDetail', { error: `HTTP status: ${response.status}` }));
          }
          return response.text();
        })
        .then(async content => {
          let fileName = fileUrl.split("/").pop();
          if (targetFolder) {
            if (!targetFolder.endsWith("/")) {
              targetFolder += "/";
            }
            fileName = targetFolder + fileName;
          }

          mp().mute_terminal = true;

          term.writeln(t('terminal.uploadingFile', { file: fileName }));

          await delay(50);

          // Send the file to the device.
          await mp().sendFile(fileName, content, false);

          await delay(300);

          await mp().sendData('\r\n');

          await delay(400);

          mp().mute_terminal = false;
        })
        .catch(error => {
          console.error("File load failed:", error);
          //alert("File load failed: " + error.message);
          show_modal_message(t('errors.fileLoadFailed'), error.message);
        });
    }



    // Download libraries from the server and upload to the device.
    async function libs_download_to_mcu() {

      if (!isEditorConnected()) {
        show_modal_message(t('errors.notConnectedTitle'), t('errors.notConnectedBody'));
        return;
      }

      const baseDir = "lib_" + userSettings.processor + "/"; // Example: "lib_ESP32/".
      const listURL = baseDir + "files.lst";

      try {
        // 2) Download the file list.
        const cfgText = await (await fetch(listURL)).text();

        // 3) Process each line.
        for (const raw of cfgText.split(/\r?\n/)) {
          const line = raw.trim();
          if (!line || line.startsWith("#")) continue;   // Skip comments and empty lines.

          const [src, dest = "/"] = line.split(";").map(p => p.trim());
          if (!src || !dest) continue;                  // Skip malformed rows.

          // 4) Upload file to the device.
          await sendFileToDevice(baseDir + src, dest);
        }

        await mp().sendData("\r\n");
      } catch (e) {
        console.error("Failed to read files.lst:", e);
        show_modal_message(t('errors.title'), t('errors.librariesConfigFailed'));
      }
    }





    // Rewrite utime imports to bletime for BLE mode.
    function rewriteUtimeToBletime(src) {
      let code = src;

      // 1) from utime import ... -> from bletime import ...
      code = code.replace(/(^|\n)\s*from\s+utime\s+import\s+/g, (m) => m.replace('utime', 'bletime'));

      // 2) import utime as X -> import bletime as X
      code = code.replace(/(^|\n)\s*import\s+utime\s+as\s+([A-Za-z_][A-Za-z0-9_]*)/g, 'import bletime as $2');

      // 3) import ..., utime, ... -> ..., bletime as utime, ...
      code = code.replace(/(^|\n)\s*import\s+([^\n#]+)/g, (full, nl, list) => {
        // Split module list and adjust only the 'utime' token.
        const parts = list.split(',').map(s => s.trim());
        let changed = false;
        const mapped = parts.map(p => {
          // Keep already rewritten entries.
          if (/^bletime(\s+as\s+utime)?$/.test(p)) return p;
          // utime without alias.
          if (p === 'utime') { changed = true; return 'bletime as utime'; }
          // utime with alias: 'utime as X' -> 'bletime as X'.
          const m = p.match(/^utime\s+as\s+([A-Za-z_][A-Za-z0-9_]*)$/);
          if (m) { changed = true; return `bletime as ${m[1]}`; }
          return p;
        });
        if (!changed) return full; // Nothing to change.
        return `${nl}import ${mapped.join(', ')}`;
      });

      // 4) import utime -> import bletime as utime
      code = code.replace(/(^|\n)\s*import\s+utime\s*(?=($|\n|#))/g, (m) => m.replace('import utime', 'import bletime as utime'));

      // 5) If utime.* is used without import, prepend bletime alias.
      const hasUtimeRef = /\butime\s*\./.test(code);
      const hasUtimeImport =
        /(^|\n)\s*import\s+utime(\s|$)/.test(code) ||
        /(^|\n)\s*from\s+utime\s+import\s+/.test(code) ||
        /(^|\n)\s*import\s+bletime\s+as\s+utime(\s|$)/.test(code) ||
        /(^|\n)\s*from\s+bletime\s+import\s+/.test(code);
      if (hasUtimeRef && !hasUtimeImport) {
        code = `import bletime as utime\r` + code;
      }

      return code;
    }





    // Guard against repeated clicks and overlapping uploads.
    let runCodeBusy = false;
    let runCodeDebounceUntil = 0;

    // Run the current code using the active transport.
    async function runCode() {
      const now = Date.now();
      if (runCodeBusy || now < runCodeDebounceUntil) return;
      runCodeDebounceUntil = now + 500;

      if (!isEditorConnected()){
        show_modal_message(t('errors.notConnectedTitle'), t('errors.notConnectedBody'));
        return;
      }

      runCodeBusy = true;
      const dev = mp();
      const prevMute = !!dev.mute_terminal;
      try {
        dev.mute_terminal = true;

        // Stop user code before upload.
        await dev.sendData('\x03');
        await delay(250);

        await dev.sendData('\x03');
        await delay(50);

        Blockly.Python.INFINITE_LOOP_TRAP = null;

        let save_code = "";
        if (projectMode === "blocks"){
          save_code = Blockly.Python.workspaceToCode(demoWorkspace);
        } else {
          const i = textProject.activeIndex;
          if (i < 0){
            show_modal_message(t('dialogs.textModeTitle'), t('dialogs.noTabOpen'));
            return;
          }
          save_code = textProject.files[i].session
            ? textProject.files[i].session.getValue()
            : (textProject.files[i].content || '');
        }

        // If BLE is active, rewrite utime -> bletime.
        if (getActiveLink && getActiveLink() === 'ble') {
          save_code = rewriteUtimeToBletime(save_code);
        }

        // Normalize newlines and remove non-ASCII.
        save_code = save_code.replace(/\r\n|\r|\n/g, "\r");
        save_code = delete_non_ascii(save_code);

        if (document.getElementById("autostart").checked) {
          save_code = "#autostart*\r" + save_code;
        }

        term.scrollToBottom();

        // Upload only the idecode file.
        await dev.sendFile("idecode", save_code, true);
        await delay(250);

        dev.mute_terminal = false;
        await dev.sendCommand('run_code()');
        await delay(20);
      } finally {
        dev.mute_terminal = prevMute;
        runCodeBusy = false;
      }
    }







    // Stop running code on the device.
    async function stopCode() {
        if (isEditorConnected())
        {
          await mp().sendData('\x03');
          await delay(200);
          await mp().sendData('\x03');
          await delay(50);
          await mp().sendData('\x03');
          await delay(50);
          await mp().sendCommand('stop_code()');
          await delay(50);
          term.scrollToBottom();
        }
        else
        {
          show_modal_message(t('errors.notConnectedTitle'), t('errors.notConnectedBody'));
        }
    }


    // Restart the processor.
    async function ResetCPU() {
        if (isEditorConnected())
        {
          await mp().sendData('\x03');
          await delay(50);
          await mp().sendData('\x03');
          await delay(20);
          await mp().sendData('\x04');
          await delay(10);
          term.scrollToBottom();
        }
        else
        {
          show_modal_message(t('errors.notConnectedTitle'), t('errors.notConnectedBody'));
        }
    }



    // Ask the device for info.
    async function get_Info() {
        if (isEditorConnected())
        {
          await mp().sendData('\x03');
          await delay(150);
          await mp().sendData('\x03');
          await delay(100);
          await mp().sendCommand('info()');
          await delay(50);
          term.scrollToBottom();
        }
        else
        {
          show_modal_message(t('errors.notConnectedTitle'), t('errors.notConnectedBody'));
        }
    }






    // Trigger haptic feedback if supported.
    function phone_vibrate() {
      try {
        navigator.vibrate(vibro_time);
      } catch {
        console.log("Cannot vibrate");
      }
    }

    // Strip diacritics to keep file names safe.
    function delete_non_ascii(in_string) {
      let sdiak = "ÁÂÄĄáâäąČčĆćÇçĈĉĎĐďđÉÉĚËĒĖĘéěëēėęĜĝĞğĠġĢģĤĥĦħÍÎíîĨĩĪīĬĭĮįİıĴĵĶķĸĹĺĻļĿŀŁłĹĽĺľŇŃŅŊŋņňńŉÓÖÔŐØŌōóöőôøŘřŔŕŖŗŠšŚśŜŝŞşŢţŤťŦŧŨũŪūŬŭŮůŰűÚÜúüűŲųŴŵÝYŶŷýyŽžŹźŻżß;@*%!+-$&?~";
      let bdiak = "AAAAaaaaCcCcCcCcDDddEEEEEEEeeeeeeGgGgGgGgHhHhIIiiIiIiIiIiIiJjKkkLlLlLlLlLLllNNNNnnnnnOOOOOOooooooRrRrRrSsSsSsSsTtTtTtUuUuUuUuUuUUuuuUuWwYYYyyyZzZzZzs;@*%!+-$&?~";
      let tx = "";
      for (let p = 0; p < in_string.length; p++) {
        if (sdiak.indexOf(in_string.charAt(p)) !== -1) {
          tx += bdiak.charAt(sdiak.indexOf(in_string.charAt(p)));
        } else {
          tx += in_string.charAt(p);
        }
      }
      return tx;
    }

    // Read a query parameter from the URL.
    function getUrlParameter(name) {
      name = name.replace(/[\[]/, '\\[').replace(/[\]]/, '\\]');
      var regex = new RegExp('[\\?&]' + name + '=([^&#]*)');
      var results = regex.exec(window.location.search);
      return results === null ? '' : decodeURIComponent(results[1].replace(/\+/g, ' '));
    }

    // Load the toolbox XML from a URL (sync).
    function loadToolbox(url) {
      var workspace = Blockly.getMainWorkspace();
      var xhr = new XMLHttpRequest();
      xhr.open('GET', url, false);
      // Update toolbox when the request finishes.
      xhr.onreadystatechange = function() {
        if(xhr.readyState == 4 && xhr.status == 200) {
          var data = xhr.responseText;
          var localized = translateToolboxXml(data);
          applyToolboxXml(localized);
          console.log("Toolbox loading succesfull.");
        }
      }
      xhr.send();
    }






      // Show the block visibility dialog and apply filters.
      async function custom_blocks_select() {
      try {
        // 1) Load stored settings.
        const saved = localStorage.getItem("userSettings");
        userSettings = saved ? JSON.parse(saved) : {};

        // 2) Load base toolbox.
        const baseXML = await fetchToolboxFile(toolboxFilename);
        originalToolboxXML = baseXML;

        /* 3) Merge with extensions. */
        const fullXML = mergeToolboxXml(baseXML, addons_toolbox);

        // 4) Show dialog with full content.
        const filterRes = await showCategoryFilterDialog(fullXML);

        /* Ignore dismiss. */
        if (!filterRes || filterRes.isDismissed || !filterRes.isConfirmed) {
          console.log("Dialog closed - keeping current toolbox.");
          return; // keep current toolbox
        }

        userSettings.filters = filterRes.value || {};

        localStorage.setItem("userSettings", JSON.stringify(userSettings));

        // 5) Apply filter.
        const filtered = filterToolboxWithFilters(fullXML, userSettings.filters);

        const localized = translateToolboxXml(filtered);
        applyToolboxXml(localized);

        console.log("Toolbox loading successful.");
      } catch (e) {
        console.error("custom_blocks_select failed:", e);
        Swal.fire(t('errors.title'), t('errors.blockVisibilityFailed'), "error");
      }
    }



    // === Processor switch and toolbox rebuild ===========================
    // This block switches the processor and reloads the toolbox.
    // It rebuilds the toolbox XML and re-applies user filters.
    async function switchProcessorAndReloadToolbox(newProc) {
      try {
        if (!newProc) return;

        // No-op if already set.
        if (userSettings && userSettings.processor === newProc) return;

        // Update userSettings and UI.
        userSettings = userSettings || {};
        userSettings.processor = newProc;
        localStorage.setItem("userSettings", JSON.stringify(userSettings));
        const procSelect = document.getElementById('processorDropdown');
        if (procSelect) procSelect.value = newProc;

        // Pick the toolbox file.
        const filename = (typeof getToolboxFilename === "function")
          ? getToolboxFilename(newProc)
          : (TOOLBOX_MAP && TOOLBOX_MAP[newProc]) || null;

        if (!filename) {
          console.warn("switchProcessorAndReloadToolbox: unknown processor or missing mapping:", newProc);
          return;
        }

        // Fetch toolbox and rebuild originalToolboxXML.
        const toolboxXML = await fetchToolboxFile(filename);
        originalToolboxXML = toolboxXML;

        const localized = buildToolboxXmlForLocale();
        applyToolboxXml(localized);

        console.log("Processor switched to:", newProc);
      } catch (e) {
        console.error("switchProcessorAndReloadToolbox failed:", e);
        Swal.fire(t('errors.title'), t('errors.switchProcessorFailed', { error: (e?.message || e) }), "error");
      }
    }
    // =====================================================================








    // Electron alert fallback.
    window.alert = (msg) => Swal.fire({icon:'info', title: msg});




    // App init.
    (function() {
      // Run init steps after window load.
      window.onload = async function() {
        applyFileManagerVisibility();

        ace.config.set('basePath', 'js');
        ace.config.set('modePath', 'js');
        ace.config.set('themePath', 'js');

        editor = ace.edit("editor");
        ace.require("ace/ext/language_tools");
        updateAceTheme(currentTheme);
        editor.session.setMode("ace/mode/python");
        editor.setOptions({
          enableBasicAutocompletion: true,
          enableSnippets: true,
          enableLiveAutocompletion: false,
          showInvisibles: true,
          fixedWidthGutter: true,
          showPrintMargin: false,
          fontFamily: '"JetBrainsMono",ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace',
          fontSize: "12px"
        });



        // Create the split layout for editor and terminal.
        Split(['#editor_div', '#terminal_div'], {
          direction: 'vertical',
          sizes: [85, 15],
          gutterSize: 6,
          cursor: 'row-resize',
          // Resize editors when dragging ends.
          onDragEnd: function(sizes) {
            var size = calculate_size(self);
            term.resize(size[0], size[1]);
            editor.renderer.updateFontSize?.();
            editor.resize();
            onresize();
          },
          // Resize editors while dragging.
          onDrag: function(sizes) {
            var size = calculate_size(self);
            term.resize(size[0], size[1]);
            editor.renderer.updateFontSize?.();
            editor.resize();
            onresize();
          }
        });

        var size = calculate_size(self);
        term = new Terminal({
          cols: size[0],
          rows: size[1],
          useStyle: true,
          screenKeys: true,
          cursorBlink: false
        });
        term.open(document.getElementById("term"), false);  // Disable auto-focus.

        editor.renderer.updateFontSize?.();
        editor.resize(true);


        // Create a new communication instance.
        mpSerial = new MicroPythonSerial(term);





        // Connect/disconnect button handlers.
        connectButton = document.getElementById('SerialConnectButton');
        bleConnectButton = document.getElementById('BLE_SerialConnectButton');


          connectButton.addEventListener("mouseenter", () => {
            switch (currentState) {
              case STATE.DISCONNECTED: updateButton(STATE.DISCONNECTED_HOVER); break;
              case STATE.CONNECTED: updateButton(STATE.CONNECTED_HOVER); break;
              case STATE.ERROR: updateButton(STATE.ERROR_HOVER); break;
            }
          });

          connectButton.addEventListener("mouseleave", () => {
            switch (currentState) {
              case STATE.DISCONNECTED_HOVER: updateButton(STATE.DISCONNECTED); break;
              case STATE.CONNECTED_HOVER: updateButton(STATE.CONNECTED); break;
              case STATE.ERROR_HOVER: updateButton(STATE.ERROR); break;
            }
          });








          if (bleConnectButton) bleUpdateButton(("bluetooth" in navigator) ? STATE.DISCONNECTED : STATE.ERROR);



            // Hover effects for BLE (same behavior as USB).
            if (bleConnectButton) {
              bleConnectButton.addEventListener("mouseenter", () => {
                switch (bleState) {
                  case STATE.DISCONNECTED: bleUpdateButton(STATE.DISCONNECTED_HOVER); break;
                  case STATE.CONNECTED:    bleUpdateButton(STATE.CONNECTED_HOVER);    break;
                  case STATE.ERROR:        bleUpdateButton(STATE.ERROR_HOVER);        break;
                }
              });
              bleConnectButton.addEventListener("mouseleave", () => {
                switch (bleState) {
                  case STATE.DISCONNECTED_HOVER: bleUpdateButton(STATE.DISCONNECTED); break;
                  case STATE.CONNECTED_HOVER:    bleUpdateButton(STATE.CONNECTED);    break;
                  case STATE.ERROR_HOVER:        bleUpdateButton(STATE.ERROR);        break;
                }
              });
            }



        // Initialize icons immediately.
        if (connectButton) {
          if ("serial" in navigator) {
            updateButton(STATE.DISCONNECTED);
            connectButton.disabled = false;
          } else {
            updateButton(STATE.ERROR);
            connectButton.disabled = true;
          }
        }

        if (bleConnectButton) {
          if ("bluetooth" in navigator) {
            bleUpdateButton(STATE.DISCONNECTED);
            bleConnectButton.disabled = false;
          } else {
            bleUpdateButton(STATE.ERROR);
            bleConnectButton.disabled = true;
          }
        }







        // Forward terminal input to the device.
        term.on('data', function(data) {
            if (isEditorConnected())
            {
              mp().sendData(data);
            }
        });

        await blocklyLanguageReady;
        Blockly.HSV_SATURATION = 0.70;
        Blockly.HSV_VALUE = 0.80;

        blocklyArea = document.getElementById('editor_div');
        blocklyDiv = document.getElementById('blocklyDiv');
        demoWorkspace = Blockly.inject('blocklyDiv', {
          toolbox: document.getElementById('toolbox'),
          zoom: {
            controls: true,
            wheel: true,
            startScale: 1.0,
            maxScale: 3,
            minScale: 0.3,
            scaleSpeed: 1.2,
            pinch: true
          },
          trashcan: true,
          media: './media/'
        });
        window.addEventListener('resize', onresize, false);
        onresize();
        Blockly.svgResize(demoWorkspace);



        // Keep generated code in sync with Blockly.
        (function(){
          const GEN_DELAY_MS = 100;           // Debounce delay.
          let dragDepth = 0;                  // Drag nesting depth.
          let timer = null;
          let pending = false;
          let lastCode = "";

          // Check if the event is UI-only (ignore it).
          function isUi(ev){
            // Compatibility via property and helper.
            return (ev && ev.isUiEvent) || (Blockly.Events && Blockly.Events.isUiEvent && Blockly.Events.isUiEvent(ev));
          }

          // Schedule code generation with debounce.
          function scheduleGen(){
            if (dragDepth > 0){ pending = true; return; }
            if (timer) { pending = true; return; }
            timer = setTimeout(runGen, GEN_DELAY_MS);
          }

          // Generate code from blocks and update the editor.
          function runGen(){
            timer = null;
            if (dragDepth > 0){ pending = true; return; }
            if (typeof projectMode !== 'undefined' && projectMode !== 'blocks') return;

            const code = Blockly.Python.workspaceToCode(demoWorkspace);
            if (code !== lastCode){
              lastCode = code;
              editor.setValue(code, 1);
            }
            if (pending){ pending = false; scheduleGen(); }
          }

          // Handle Blockly workspace changes.
          function onWsChange(ev){
            if (!ev) return;
            if (isUi(ev)) return;

            switch (ev.type){
              case Blockly.Events.BLOCK_DRAG:
                // Newer versions expose isStart.
                if (ev.isStart) { dragDepth++; }
                else { dragDepth = Math.max(0, dragDepth - 1); scheduleGen(); }
                return;

              case Blockly.Events.FINISHED_LOADING:
              case Blockly.Events.BLOCK_CREATE:
              case Blockly.Events.BLOCK_DELETE:
              case Blockly.Events.BLOCK_CHANGE:
              case Blockly.Events.BLOCK_MOVE:
                scheduleGen();
                return;

              default:
                // Ignore other system events.
                return;
            }
          }

          demoWorkspace.addChangeListener(onWsChange);
        })();






        // Open the image editor from a Blockly button.
        demoWorkspace.registerButtonCallback('open_image_editor', function(button) {
          const lang = normalizeLanguage(currentLanguage || document.documentElement.lang || "en");
          window.open(`img_editor_${lang}.html`, t('dialogs.imageEditorTitle'), 'left=300,top=140,width=260,height=340,popup');
        });







        // Wire the mode radio buttons.
        const rbBlocks = document.getElementById('modeBlocks');
        const rbText   = document.getElementById('modeText');
        rbBlocks.addEventListener('change', ()=> rbBlocks.checked && switchUITo("blocks"));
        rbText  .addEventListener('change', ()=> rbText.checked   && switchUITo("text"));

        // Initialize Ace for the text editor tabs.
        function initAceText(){
              aceText = ace.edit("aceText");
              ace.require("ace/ext/language_tools");

              // Types for session and correct UndoManager constructor.
              AceEditSession = ace.require("ace/edit_session").EditSession;
              const umMod = ace.require("ace/undomanager");
              AceUndoManagerCtor = umMod && umMod.UndoManager ? umMod.UndoManager : null;

              updateAceTheme(currentTheme);
              aceText.setOptions({
                enableBasicAutocompletion: true,
                enableSnippets: true,
                enableLiveAutocompletion: false,
                showInvisibles: true,
                fixedWidthGutter: true,
                showPrintMargin: false,
                fontFamily: '"JetBrainsMono",ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace',
                fontSize: "12px"
              });

              // Mark the active tab dirty on edit.
              aceText.on('change', ()=>{
                const i = textProject.activeIndex;
                if (i >= 0){
                  textProject.files[i].dirty = true;
                  saveTextProjectToLS();
                  renderTabs();
                }
              });

              restoreTextProjectFromLS();
              if (textProject.files.length === 0) ensureOneDefaultTab();

              activateTab(Math.max(0, textProject.activeIndex));
              renderTabs();
              setupDnDForEditors();
        }


        // Finish Ace setup now that the editor is ready.
        initAceText();
        aceText.renderer.updateFontSize?.();
        aceText.resize();




        // Restore the last saved mode.
        const savedMode = localStorage.getItem("espide.projectMode") || "blocks";
        document.getElementById(savedMode==="text" ? "modeText" : "modeBlocks").checked = true;
        switchUITo(savedMode);











        try {
            // Load startup params from the URL.
            const params = new URL(window.location.href).searchParams;
            const toolboxParam = params.get('toolbox');
            const programParam = params.get('program');
            const processorParam = params.get('processor') || params.get('proc');
            const forcedToolbox = normalizeForcedToolbox(force_toolbox);
            const forcedProcessor = forcedToolbox ? resolveProcessorForToolbox(forcedToolbox) : null;

            function resolveProcessorParam(value){
              if (!value) return null;
              const lowered = String(value).toLowerCase();
              const match = Object.keys(TOOLBOX_MAP).find(
                (key) => key.toLowerCase() === lowered
              );
              return match || null;
            }
            const processorOverride = resolveProcessorParam(processorParam);
            if (processorParam && !processorOverride) {
              console.warn("Unknown processor param:", processorParam);
            }


            // Load stored settings from localStorage.
            var saved = localStorage.getItem("userSettings");
            if (saved) {
              userSettings = JSON.parse(saved);
              console.log("Loaded user settings: " + saved);
            } else {
              userSettings = {};
              console.log("User settings not found. Using defaults.");
            }

            userSettings.theme = normalizeTheme(userSettings.theme || currentTheme);
            currentTheme = userSettings.theme;

            // Init the processor dropdown.
            const procSelect = document.getElementById('processorDropdown');
            procSelect.addEventListener('change', e => updateProcessor(e.target.value));

            if (forcedToolbox) {
              if (forcedProcessor) {
                userSettings.processor = forcedProcessor;
              }
              procSelect.value = (userSettings && userSettings.processor) || 'ESP32';
              procSelect.disabled = true;
              procSelect.style.display = 'none';
              updateBleVisibility(procSelect.value);
              toolboxFilename = forcedToolbox;
            } else {
              // Apply processor override from URL before setting defaults.
              if (processorOverride) {
                userSettings.processor = processorOverride;
              }

              // Set initial value from localStorage (or default ESP32).
              procSelect.value = (userSettings && userSettings.processor) || 'ESP32';

              // Show or hide Bluetooth button based on processor.
              updateBleVisibility(procSelect.value);

              // 2) If toolboxParam is present, use it instead of dialog.
              if (toolboxParam) {
                toolboxFilename = toolboxParam;  // external override
              } else if (userSettings.processor && TOOLBOX_MAP[userSettings.processor]) {
                toolboxFilename = TOOLBOX_MAP[userSettings.processor];
              } else {
                // Do not store processor yet - show the dialog
                //const procResult = await showProcessorDialog();
                //userSettings.processor = procResult.value.processor;
                userSettings.processor = "ESP32";

                document.getElementById('processorDropdown').value = userSettings.processor;
                //userSettings.processor = "ESPBIT";
                toolboxFilename = getToolboxFilename(userSettings.processor);
              }
            }



            var toolboxXML = await fetchToolboxFile(toolboxFilename);
            originalToolboxXML = toolboxXML; // Store original content.

            // If filter config is missing, use empty filters.
            if (!userSettings.filters) {
              //const filterResult = await showCategoryFilterDialog(originalToolboxXML);
              //userSettings.filters = filterResult.value;
              userSettings.filters = {};
            }

            // Persist settings to localStorage.
            localStorage.setItem("userSettings", JSON.stringify(userSettings));


            // Load new blocks from extensions.
            safeLoadExtensionsOnStartup();


            const localized = buildToolboxXmlForLocale();
            applyToolboxXml(localized);
            console.log("Toolbox loading succesfull (start).");


            // 4) If programParam is set, load the program XML.
            if (programParam) {
              try {
                const resp = await fetch(programParam);
                let rawText = await resp.text();

                // Extract payload and clean XML.
                const { payload, strippedText } = peelExtensionsComment(rawText);

                // 4a) Switch processor before integrating extensions.
                if (payload?.processor && payload.processor !== (userSettings && userSettings.processor)) {
                  await switchProcessorAndReloadToolbox(payload.processor);
                }

                // 4b) Integrate extensions.
                if (payload?.extensions && Array.isArray(payload.extensions)) {
                  mergeAndIntegrateExtensionsFromPayload(payload);
                }

                // 4c) Load XML into workspace.
                const xmlDom = Blockly.Xml.textToDom(strippedText);
                demoWorkspace.clear();
                Blockly.Xml.domToWorkspace(xmlDom, demoWorkspace);

                // Sync text editor.
                editor.setValue(Blockly.Python.workspaceToCode(demoWorkspace), 1);
              } catch (e) {
                console.error('Program load failed:', e);
                Swal.fire(t('errors.title'), t('errors.programLoadFailed', { error: (e?.message || e) }), "error");
              }
            }



        } catch (e) {
            console.error("Initialization failed:", e);
            Swal.fire(t('errors.title'), t('errors.appInitFailed'), "error");
        }





        if ("serial" in navigator) {

            // Handle USB connect/disconnect click.
            connectButton.addEventListener("click", () => withConnectLock(async () => {
              if (currentState === STATE.DISCONNECTED || currentState === STATE.DISCONNECTED_HOVER || currentState === STATE.ERROR || currentState === STATE.ERROR_HOVER) {
                try {
                  await ensureExclusive('usb');
                  await mpSerial.connect();

                  if (!mpSerial.port) {
                                term.writeln(t('terminal.noPortSelected'));
                    updateButton(STATE.ERROR);
                    return;
                  }
                  updateButton(STATE.CONNECTED);
                  activeLink = 'usb';
                  closeQuick();
                } catch(e){
                  console.error("Connection failed:", e);
                  updateButton(STATE.ERROR);
                }
              } else if (currentState === STATE.CONNECTED || currentState === STATE.CONNECTED_HOVER) {
                try {
                  await mpSerial.disconnect();
                  updateButton(STATE.DISCONNECTED);
                  activeLink = isBleConnected() ? 'ble' : 'none';
                } catch(e){
                  console.error("Disconnect failed:", e);
                  updateButton(STATE.ERROR);
                }
              }
            }));

            // Handle USB disconnect from the browser.
            navigator.serial.addEventListener("disconnect", (event) => {
              if (mpSerial.port && event.target === mpSerial.port) {
                console.warn(t('status.deviceDisconnected'));
                updateButton(STATE.ERROR);
                if (activeLink === 'usb') activeLink = isBleConnected() ? 'ble' : 'none';
                mpSerial.reader = null; mpSerial.writer = null;
                mpSerial.disconnect(); mpSerial.port = null;
                openQuick(); // Open quick panel after unexpected disconnect.
              }
            });

              // Handle USB device connection events.
              navigator.serial.addEventListener("connect", (event) => {
                console.log("New device connected");
                if (currentState === STATE.DISCONNECTED || currentState === STATE.DISCONNECTED_HOVER || currentState === STATE.ERROR || currentState === STATE.ERROR_HOVER) {
                    Swal.fire({
                      title: t('status.deviceConnectedTitle'),
                      text: t('status.deviceConnectedText'),
                      showCancelButton: true,
                      confirmButtonText: t('actions.yes'),
                      cancelButtonText: t('actions.no'),
                      backdrop: false,       // No full-screen backdrop.
                      heightAuto: false,     // Prevent <body> resize.
                      willClose: () => {     // Quick refresh after close.
                        requestAnimationFrame(() => {
                          if (projectMode === "text") { try { aceText && aceText.resize(); } catch(_){} }
                          else { try { onresize(); Blockly.svgResize(demoWorkspace); } catch(_){} }
                        });
                      }
                    }).then(async (result) => {
                      if (result.isConfirmed) {
                        if (currentState === STATE.DISCONNECTED || currentState === STATE.DISCONNECTED_HOVER || currentState === STATE.ERROR || currentState === STATE.ERROR_HOVER) {
                        try {
                              await mpSerial.connect();

                              if (!mpSerial.port) {
                                term.writeln(t('terminal.noPortSelected'));
                                updateButton(STATE.ERROR);
                                return;
                              }
                              updateButton(STATE.CONNECTED);

                              try { await mpBLE?.disconnect(); } catch (_) {}
                              mpBLE = null; // drop old instance

                              activeLink = 'usb';
                              closeQuick();


                            } catch(e){
                              console.error("Connection failed:", e);
                              updateButton(STATE.ERROR);
                            }
                        }
                        //connectButton.click();  // simulate click on connect button
                      }
                    });
                  }
               });


            updateButton(STATE.DISCONNECTED);
          }
          else
          {
            updateButton(STATE.ERROR);
          }














            // BLE toggle logic and connection handling.
            if (bleConnectButton) {
              // Initial state based on browser support.
              if (!("bluetooth" in navigator)) {
                bleConnectButton.disabled = true;
                bleUpdateButton(STATE.ERROR);
              } else {
                bleUpdateButton(STATE.DISCONNECTED);
              }

                // Handle BLE connect and disconnect click.
                bleConnectButton.addEventListener("click", () => withConnectLock(async () => {
                  try {
                    if (bleState === STATE.DISCONNECTED || bleState === STATE.DISCONNECTED_HOVER
                        || bleState === STATE.ERROR || bleState === STATE.ERROR_HOVER) {

                      await ensureExclusive('ble');

                      try { await mpBLE?.disconnect(); } catch (_) {}
                      mpBLE = null;                               // drop old instance
                      activeLink = (typeof isUsbConnected === 'function' && isUsbConnected()) ? 'usb' : 'none';

                      if (!mpBLE) mpBLE = new MicroPythonBLE(term, (s) => {
                        bleUpdateButton(s);
                        try { window.__espideGamepad?.updateIcon(); } catch(_) {}

                        if (s === STATE.CONNECTED) activeLink = 'ble';
                        if (s === STATE.DISCONNECTED || s === STATE.ERROR) {
                            activeLink = (typeof isUsbConnected === 'function' && isUsbConnected()) ? 'usb' : 'none';
                            if (!bleUserDisconnecting) openQuick(); // Auto-open on unexpected disconnect.
                        }
                      });

                      await mpBLE.connect();
                      bleUpdateButton(STATE.CONNECTED);
                      activeLink = 'ble';

                      try { window.__espideGamepad?.updateIcon(); } catch(_) {}

                      closeQuick()

                    } else if (bleState === STATE.CONNECTED || bleState === STATE.CONNECTED_HOVER) {
                      bleUserDisconnecting = true;
                      try { if (mpBLE) await mpBLE.disconnect(); } finally { bleUserDisconnecting = false; }
                      bleUpdateButton(STATE.DISCONNECTED);
                      activeLink = 'usb';
                    }
                  } catch (err) {
                      console.error("BLE error:", err);

                      // Safely extract error text (avoid e.includes -> TypeError).
                      const msg  = (err && typeof err === 'object' && 'message' in err) ? err.message : String(err);
                      const name = (err && err.name) ? err.name : '';

                      // User closed the device picker -> stay disconnected.
                      if (name === 'NotFoundError' || /User cancelled|No device selected/i.test(msg)) {
                        bleUpdateButton(STATE.DISCONNECTED);
                        return;
                      }

                      // Hard cleanup after error so manual reconnect works without reload.
                      try { await mpBLE?.disconnect(); } catch (_) {}
                      mpBLE = null;                               // drop old instance
                      activeLink = (typeof isUsbConnected === 'function' && isUsbConnected()) ? 'usb' : 'none';

                      // Show the error and keep DISCONNECTED state.
                      show_modal_message(t('errors.bluetoothErrorTitle'), msg);
                      bleUpdateButton(STATE.DISCONNECTED);
                  }
                }));
            }


            // Unsupported browser message.
            if ((!("serial" in navigator)) && (!("bluetooth" in navigator)))  {
                show_modal_message(t('errors.unsupportedBrowserTitle'), t('errors.unsupportedBrowserBody'));
            }












        //loadToolbox("toolbox.xml");

        // Drag and drop for block files.
        function showDropZone() {
        // Show global zone only when extensions dialog is closed.
          if (document.getElementById('extensions_dialog')?.style.display !== 'block') {
            document.getElementById('drop_zone').style.display = 'block';
          }
        }

        // Hide the global drop zone.
        function hideDropZone() {
          document.getElementById('drop_zone').style.display = 'none';
        }
        // FM guard: ignore global DnD when FileManager is open.
        window.__FM_ACTIVE = window.__FM_ACTIVE || false;
        // Prevent default DnD behavior outside the editor.
        function preventDefaults(e) {
          if (window.__FM_ACTIVE || projectMode !== 'blocks') return;
          e.preventDefault();
          e.stopPropagation();
        }
        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
          document.addEventListener(eventName, preventDefaults, false);
        });

        // Show drop zone on drag enter.
        document.addEventListener('dragenter', function(e) {
          if (window.__FM_ACTIVE || projectMode !== 'blocks') return;
          showDropZone();
        });

        // Hide drop zone when the drag leaves the window.
        document.addEventListener('dragleave', function(e) {
          if (window.__FM_ACTIVE || projectMode !== 'blocks') return;
          if (e.clientX === 0 && e.clientY === 0) { hideDropZone(); }
        });
        // Handle drop of a project file.
        document.addEventListener('drop', async function(e) {
          if (window.__FM_ACTIVE || projectMode !== 'blocks') return;
          hideDropZone();
          var files = e.dataTransfer.files;
          if (files.length > 0) {
            var file = files[0];
            document.getElementById("save_filename").value = file.name.replace(".xml", "").replace(".blk", "");
            var reader = new FileReader();
            // Read file content and load it into Blockly.
            reader.onload = async function(e) {
              try {
                var contents = e.target.result;

                const { payload, strippedText } = peelExtensionsComment(contents);

                // 4a) Switch processor before integrating extensions.
                if (payload?.processor && payload.processor !== (userSettings && userSettings.processor)) {
                  await switchProcessorAndReloadToolbox(payload.processor);
                }

                // 4b) Integrate extensions.
                if (payload?.extensions && Array.isArray(payload.extensions)) {
                  mergeAndIntegrateExtensionsFromPayload(payload);
                }

                // 4c) Load XML.
                var xml = Blockly.Xml.textToDom(strippedText);
                demoWorkspace.clear();
                Blockly.Xml.domToWorkspace(xml, demoWorkspace);
              } catch (err) {
                show_modal_message(t('errors.fileLoadFailed'), err.message);
              }
            };

            reader.readAsText(file);
          }
        });

        document.addEventListener('dragover', function(e) {
          if (window.__FM_ACTIVE || projectMode !== 'blocks') return;
          if (e.dataTransfer) e.dataTransfer.dropEffect = 'copy';
        });



        // Drag and drop into the extensions zone.
        const dropZone = document.getElementById("ext_drop");
        const extFileInput = document.getElementById("ext_file_input");
        const extFileBtn = document.getElementById("ext_file_btn");

        function handleExtensionFiles(fileList){
          [...(fileList || [])].forEach(f=>{
            if(!/\.newblk$/i.test(f.name)) return;
            const reader = new FileReader();
            reader.onload = ev=>{
              const raw = ev.target.result;
              if (!raw.includes("<!toolbox!>")) {
                 Swal.fire(
                   t('errors.invalidExtensionTitle'),
                   t('errors.invalidExtensionBody'),
                   "warning"
                 );
                 return;
              }
              const [codeJS, toolboxXML=""] = raw.split("<!toolbox!>");
              const baseName = f.name.replace(/\.newblk$/i,"");
              extensions[baseName] = { js: codeJS, xml: toolboxXML, enabled:true };
              refreshExtList();
            };
            reader.readAsText(f,"utf-8");
          });
        }

        if (extFileBtn && extFileInput){
          extFileBtn.addEventListener("click", ()=> extFileInput.click());
          extFileInput.addEventListener("change", e=>{
            handleExtensionFiles(e.target.files);
            e.target.value = "";
          });
        }

        ["dragenter","dragover"].forEach(ev=>dropZone.addEventListener(ev,e=>{
          if (window.__FM_ACTIVE) return;
          e.preventDefault(); e.stopPropagation(); dropZone.style.background="#e8eaf6";
        }));
        ["dragleave","drop"].forEach(ev=>dropZone.addEventListener(ev,e=>{
          if (window.__FM_ACTIVE) return;
          e.preventDefault(); e.stopPropagation(); dropZone.style.background="";
        }));
        dropZone.addEventListener("drop", e=>{
          if (window.__FM_ACTIVE) return;
          handleExtensionFiles(e.dataTransfer.files);
        });



        // Preload images for the connect button.
        usbImages.forEach(src => {
            const img = new Image();
            img.src = src;
        });

        // Preload images for the connect button.
        bleImages.forEach(src => {
            const img = new Image();
            img.src = src;
        });

        // Resize terminal on window resize.
        window.addEventListener('resize', function() {
            var size = calculate_size(self);
            term.resize(size[0], size[1]);
        });




      const qpBtn   = document.getElementById('quick_panel_button');
      const qp      = document.getElementById('quick_panel');
      const qpInner = document.getElementById('quick_panel_inner') || document.getElementById('quick_panel_row');

      const elSerial = document.getElementById('SerialConnectButton');
      const elBle    = document.getElementById('BLE_SerialConnectButton');
      const elProc   = document.getElementById('processorDropdown');
      const elMode   = document.getElementById('modeSwitch');

      let qpInitDone = false;        // auto-open only once after load
      let qpWantedOpen = null;       // last known user intent (true/false)
      let bleUserDisconnecting = false; // detect manual BLE disconnect



      // Panel order (customizable).
      const panelOrder = [elProc, elMode, elSerial, elBle];

      // Fixed X positions inside the panel.
      const FIXED_X = {
        processorDropdown:        400,
        modeSwitch:               205,
        SerialConnectButton:       20,
        BLE_SerialConnectButton:  130
      };

      // Get a stable key for an element.
      function key(el){
        return el?.id || '';
      }

      // Placeholders and original inline styles (once).
      const placeholders = new Map();
      const origStyle = new Map(); // Key = element, value = original inline style.

      // Create placeholders and store original styles.
      function ensurePlaceholders(){
        for (const el of panelOrder){
          if (!el) continue;
          if (!placeholders.has(el)){
            const ph = document.createElement('span');
            el.after(ph);
            placeholders.set(el, ph);
          }
          if (!origStyle.has(el)){
            // Store original inline styles for exact restore.
            const s = el.getAttribute('style');
            origStyle.set(el, s == null ? null : s);
          }
        }
      }

      // Set the quick panel height.
      function setPanelHeight(){
        // Keep panel height constant.
        const h = 44;
        document.documentElement.style.setProperty('--qp-h', h + 'px');
      }


        // Render the USB icon in the quick panel.
        function renderUsbIcon(){
          if (!window.SerialConnectButton) return; // Or use elSerial.
          const el = document.getElementById('SerialConnectButton');
          if (!el) return;
          // currentState and usbImages are already defined.
          el.style.backgroundImage = 'url("' + (usbImages[currentState] || usbImages[0]) + '")';
        }

        // Render the BLE icon in the quick panel.
        function renderBleIcon(){
          const el = document.getElementById('BLE_SerialConnectButton');
          if (!el) return;
          el.style.backgroundImage = 'url("' + (bleImages[typeof bleState==='number'?bleState:0] || bleImages[0]) + '")';
        }

        // Render both connect icons.
        function renderConnectIcons(){
          try { renderUsbIcon(); } catch(_){}
          try { renderBleIcon(); } catch(_){}
        }




      // Move the controls into the quick panel.
      function moveToPanel(){
        ensurePlaceholders();
        for (const el of panelOrder){
          if (!el || el.parentNode === qpInner) continue;
          el.classList.add('in-panel');
          qpInner.appendChild(el);
          // Panel position: fixed X from FIXED_X, Y via CSS.
          const k = key(el);
          if (k in FIXED_X) el.style.left = FIXED_X[k] + 'px';
          el.style.bottom = '8px';
          el.style.position = 'absolute';
        }
        setPanelHeight();
        renderConnectIcons();
      }

      // Restore controls to their original place.
      function restoreFromPanel(){
        for (const el of panelOrder){
          if (!el) continue;
          const ph = placeholders.get(el);
          if (!ph || !ph.parentNode) continue;

          // Remove panel class.
          el.classList.remove('in-panel');

          // Restore original inline styles.
          const saved = origStyle.get(el);
          if (saved === null){
            // No inline style originally.
            el.removeAttribute('style');
          } else {
            el.setAttribute('style', saved);
          }

          // Restore original DOM position.
          ph.parentNode.insertBefore(el, ph.nextSibling);
        }
        document.documentElement.style.removeProperty('--qp-h');
        renderConnectIcons();
      }

      // Open the quick panel.
      function openQuick(){
          qp.classList.add('open');
          document.body.classList.add('quick-open');
          qpWantedOpen = true;
          if (qpBtn) qpBtn.textContent = '▴';
      }

      // Close the quick panel.
      function closeQuick(){
          qp.classList.remove('open');
          document.body.classList.remove('quick-open');
          qpWantedOpen = false;
          if (qpBtn) qpBtn.textContent = '▾';
      }

      // Move controls based on viewport width.
      function layoutResponsive(){
          const narrow = window.innerWidth <= 1150;
          if (narrow){
            moveToPanel();
            if (!qpInitDone) {
              // First render: open panel.
              openQuick();
              if (qpBtn) qpBtn.style.display = 'block';
              qpInitDone = true;
            } else {
              // Later resize: respect last user choice.
              if (qpWantedOpen) openQuick(); else closeQuick();
              if (qpBtn) qpBtn.style.display = 'block';
            }
          } else {
            restoreFromPanel();
            closeQuick();
            if (qpBtn) qpBtn.style.display = 'none';
          }
          setTimeout(()=>{
            try { if (window.demoWorkspace) { onresize(); Blockly.svgResize(demoWorkspace); } } catch(_){}
            try { if (window.aceText) { aceText.resize(); } } catch(_){}
          }, 80);
      }

      // Toggle the quick panel on button click.
      if (qpBtn){
        qpBtn.addEventListener('click', ()=>{
          const isOpen = qp.classList.contains('open');
          if (isOpen){ closeQuick(); }
          else { moveToPanel(); openQuick(); }
          setTimeout(()=>{
            try { if (window.demoWorkspace) { onresize(); Blockly.svgResize(demoWorkspace); } } catch(_){}
            try { if (window.aceText) { aceText.resize(); } } catch(_){}
          }, 120);
        });
      }

      // Auto-close after connection.
      let autoClosed = false;
      setInterval(()=>{
        try{
          if (!autoClosed && typeof isEditorConnected === 'function' && isEditorConnected()){
            closeQuick(); autoClosed = true;
          }
        }catch(_){}
      }, 400);

      window.addEventListener('resize', layoutResponsive);
      layoutResponsive();

      setTheme(currentTheme, { persist: false });
      hideLoadingScreen();








      };


    }).call(this);

    // Calculate terminal columns and rows based on size.
    function calculate_size(win) {
      var cols = (getWidth() / 6.2) | 0;
      var rows = (document.getElementById("terminal_div").offsetHeight / 13.5) | 0;
      return [cols, rows];
    }

    // Get full document width.
    function getWidth() {
      return Math.max(
        document.body.scrollWidth,
        document.documentElement.scrollWidth,
        document.body.offsetWidth,
        document.documentElement.offsetWidth,
        document.documentElement.clientWidth
      );
    }

    // Get full document height.
    function getHeight() {
      return Math.max(
        document.body.scrollHeight,
        document.documentElement.scrollHeight,
        document.body.offsetHeight,
        document.documentElement.offsetHeight,
        document.documentElement.clientHeight
      );
    }

    // Close the code preview dialog.
    function close_code() {
      document.getElementById("code_dialog").style.display = "none";
      code_window_open = false;
    }

    // Show the code preview dialog.
    function showCode() {
      if (!code_window_open) {
        Blockly.Python.INFINITE_LOOP_TRAP = null;
        var str_code = Blockly.Python.workspaceToCode(demoWorkspace);
        editor.setValue(str_code, 1);
        document.getElementById("code_dialog").style.display = "block";
        code_window_open = true;
      } else {
        close_code();
        code_window_open = false;
      }
    }

    // Close the save dialog.
    function close_save() {
      document.getElementById("save_dialog").style.display = "none";
    }

    // Open the save dialog for project download.
    function save_file_dialog() {
      document.getElementById("save_dialog_btn").disabled = false;
      document.getElementById("save_dialog_btn").value = t('dialogs.saveButton');
      document.getElementById("save_dialog").style.display = "block";
    }

    // Download text as a local file.
    function file_download(filename, text) {
      var element = document.createElement('a');
      element.setAttribute('href', 'data:application/xml;charset=utf-8,' + encodeURIComponent(text));
      element.setAttribute('download', filename);
      element.style.display = 'none';
      document.body.appendChild(element);
      element.click();
      document.body.removeChild(element);
    }

    // Save the current Blockly project to the PC.
    function code_download_pc() {
      var xml = Blockly.Xml.workspaceToDom(demoWorkspace);
      var xml_text = Blockly.Xml.domToText(xml);

      // Embed used extensions into the project file.
      let used = [];
      try { used = pickUsedExtensions(xml_text) || []; } catch(_) { used = []; }
      const payload = { version:1, processor:(userSettings&&userSettings.processor)||null, extensions: used };
      const blob = utf8_to_b64(JSON.stringify(payload));

      // Insert inside </xml> instead of appending after it.
      const final_text = injectExtensionsIntoXml(xml_text, blob);

      let project_name = document.getElementById("save_filename").value;
      if (!project_name) {
        alert(t('dialogs.projectNameRequired'));
      } else {
        if (project_name.endsWith('.xml') || project_name.endsWith('.blk')) {
          file_download(project_name, final_text);
        } else {
          file_download(project_name + ".blk", final_text);
        }
      }
      close_save();
    }


    // Open the file picker and load a project from the PC.
    function code_upload_pc() {
      document.getElementById('upload_file_input').addEventListener('change', readSingleFile, false);
      document.getElementById('upload_file_input').click();
    }

    // Read a single file and load it into Blockly.
    function readSingleFile(e) {
      var file = e.target.files[0];
      if (!file) return;
      document.getElementById("save_filename").value = file.name.replace(/\.xml$|\.blk$/i, "");
      var reader = new FileReader();
      // Parse the file after it is loaded.
      reader.onload = async function(ev) {
          try {
            var contents = ev.target.result;

            const { payload, strippedText } = peelExtensionsComment(contents);

            // 3a) Switch processor before integrating extensions.
            if (payload?.processor && payload.processor !== (userSettings && userSettings.processor)) {
              await switchProcessorAndReloadToolbox(payload.processor);
            }

            // 3b) Integrate extensions.
            if (payload?.extensions && Array.isArray(payload.extensions)) {
              mergeAndIntegrateExtensionsFromPayload(payload);
            }

            // 3c) Load clean XML into workspace.
            var xml = Blockly.Xml.textToDom(strippedText);
            demoWorkspace.clear();
            Blockly.Xml.domToWorkspace(xml, demoWorkspace);
            this.value = "";
          } catch (err) {
            alert(err);
          }
        };
      reader.readAsText(file);
    }



    // Prevent page unload (web only).
    const isElectron = (typeof navigator !== 'undefined' && /Electron/i.test(navigator.userAgent)) || !!(globalThis.process?.versions?.electron);

    if (!isElectron) {
      const UNLOAD_GUARD_DELAY_MS = 30000;
      setTimeout(() => {
        window.onbeforeunload = (e) => { e.preventDefault(); e.returnValue = ''; };
      }, UNLOAD_GUARD_DELAY_MS);
    }


    // Update the More menu labels based on mode.
    function updateMoreMenuLabels(){
      const openBtn = document.getElementById('menuOpenBtn');
      const saveBtn = document.getElementById('menuSaveBtn');
      const shareBtn = document.getElementById('menuShareBtn');
      if (!openBtn || !saveBtn) return;

      if (projectMode === 'text'){
        openBtn.textContent = t('menu.openFileText');
        openBtn.title = t('menu.openFileTitle');
        saveBtn.textContent = t('menu.saveFileText');
        saveBtn.title = t('menu.saveFileTitle');
        if (shareBtn) {
          shareBtn.textContent = t('menu.shareFile');
          shareBtn.title = t('menu.shareFileTitle');
        }
      } else {
        openBtn.textContent = t('menu.openProject');
        openBtn.title = t('menu.openProjectTitle');
        saveBtn.textContent = t('menu.saveProject');
        saveBtn.title = t('menu.saveProjectTitle');
        if (shareBtn) {
          shareBtn.textContent = t('menu.shareProject');
          shareBtn.title = t('menu.shareProjectTitle');
        }
      }
    }




    // Toggle the More menu.
    function showDropdown() {
      var x = document.getElementById("more_menu");
      const willOpen = (x.style.display === "none" || x.style.display === "");
      x.style.display = willOpen ? "block" : "none";
      if (willOpen) updateMoreMenuLabels();
    }




    // Build the device path for the active text tab.
    function getActiveTabDevicePath(){
      if (!textProject || textProject.activeIndex < 0) return null;
      const raw = String(textProject.files[textProject.activeIndex]?.name || '').trim();
      if (!raw) return null;

      // Allow "folder/file.py" and "file.py".
      let p = raw.startsWith('/') ? raw : '/' + raw;

      // Normalize //, ., .. safely.
      p = p.replace(/\/+/g, '/');
      const parts = [];
      for (const seg of p.split('/')){
        if (!seg || seg === '.') continue;
        if (seg === '..'){ parts.pop(); continue; }
        parts.push(seg);
      }
      return '/' + parts.join('/');
    }

    // Save the active text tab to the connected device.
    async function saveActiveTabToESP(){
      if (!textProject || textProject.activeIndex < 0 || !textProject.files.length){
        alert(t('dialogs.noTabOpen')); return;
      }
      const f   = textProject.files[textProject.activeIndex];
      const dst = getActiveTabDevicePath();
      if (!dst){ show_modal_message(t('errors.invalidFileNameTitle'), t('errors.invalidTabName')); return; }

      if (typeof isEditorConnected === 'function' ? !isEditorConnected() : true){
        // Use the same message as File Manager.
        if (typeof showNotConnected === 'function') showNotConnected();
        else show_modal_message(t('errors.notConnectedTitle'), t('errors.notConnectedBody'));
        return;
      }

      const content = f.session ? f.session.getValue() : (f.content || '');

      try{
        if (typeof term !== 'undefined' && term && term.writeln) term.writeln(t('terminal.savingFile', { file: dst }));
        if (mp()) mp().mute_terminal = true;

        // Main upload (same channel as File Manager).
        await mp().sendFile(dst, content, false);  // string is supported just like Uint8Array

        await delay(250);
        if (mp()) mp().mute_terminal = false;
        await mp().sendData('\r\n');
        await delay(50);

        // Mark tab as saved.
        if (f.dirty){ f.dirty = false; renderTabs(); }
        saveTextProjectToLS();
      } catch(e){
        if (mp()) mp().mute_terminal = false;
        show_modal_message(t('errors.saveFailedTitle'), String(e && e.message || e));
      }
    }








    // Download the active text tab to the PC.
    function saveActiveTabAsFile(){
      if (!textProject || textProject.activeIndex < 0 || !textProject.files.length){
        alert(t('dialogs.noTabOpen'));
        return;
      }
      var f = textProject.files[textProject.activeIndex];
      var name = f.name || 'soubor.py';
      var content = f.session ? f.session.getValue() : (f.content || '');

      var blob = new Blob([content], {type:'text/plain;charset=utf-8'});
      var a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = name;
      document.body.appendChild(a);
      a.click();
      setTimeout(function(){
        URL.revokeObjectURL(a.href);
        document.body.removeChild(a);
      }, 0);

      // After download, tab is no longer dirty.
      if (f.dirty){ f.dirty = false; renderTabs(); }
      saveTextProjectToLS();
    }


    // Open a local file into the active text tab.
    function openFileIntoActiveTab(){
      // Ensure at least one tab exists.
      if (!textProject || textProject.files.length === 0){
        ensureOneDefaultTab();
      }
      var i = textProject.activeIndex;
      if (i < 0) i = 0;

      var inp = document.createElement('input');
      inp.type = 'file';
      inp.accept = '.py,.txt';
      inp.onchange = function(e){
        var file = e.target.files && e.target.files[0];
        if (!file) return;

        var reader = new FileReader();
        // Load file content into the tab.
        reader.onload = function(){
          var txt = String(reader.result || '');
          var parts = splitNameExt(file.name);
          var newName = uniqueFileName(parts.base, parts.ext, i); // Keep unique among tabs.

          var f = textProject.files[i];

          // Rename tab (uniquely) and set content.
          f.name = newName;

          if (f.session){
            f.session.setValue(txt);
          } else {
            // Fallback if session is not available yet.
            f.content = txt;
            if (aceText) aceText.setValue(txt, -1);
          }

          f.dirty = false;          // Freshly loaded -> clean.
          activateTab(i);           // Show tab.
          renderTabs();
          saveTextProjectToLS();
        };
        reader.readAsText(file, 'utf-8');
      };
      inp.click();
    }

    // Split filename into base and extension.
    function splitNameExt(filename){
      var m = /^(.+?)(?:\.([^.]+))?$/.exec(filename || '');
      return {
        base: (m && m[1]) ? m[1] : t('textProject.defaultBaseName'),
        ext:  (m && m[2]) ? m[2] : 'py'
      };
    }

    // Build a unique file name (ignore current tab index).
    function uniqueFileName(base, ext, ignoreIndex){
      base = (base || t('textProject.defaultBaseName')).replace(/[\\:*?"<>|]/g, '_'); // Keep "/" in whitelist.
      ext  = (ext  || 'py').replace(/[\\:*?"<>|]/g, '');
      const taken = {};
      for (let idx=0; idx<textProject.files.length; idx++){
        if (idx === ignoreIndex) continue;
        taken[textProject.files[idx].name] = true;
      }
      let n = 1, name = base + '.' + ext;
      while (taken[name]){ name = base + n + '.' + ext; n++; }
      return name;
    }

    // Handle file drops onto the text editor.
    async function handleTextDrop(e){
      try{
        const files = Array.from((e.dataTransfer && e.dataTransfer.files) || []);
        if (!files.length) return;
        for (const file of files){
          const content = await file.text();     // Text files only.
          addNewTab(file.name, content);         // Reuse existing logic.
        }
        if (aceText) aceText.focus();
      }catch(err){
        show_modal_message && show_modal_message(t('errors.fileOpenFailedTitle'), String(err && err.message || err));
      }
    }

    // Set up drag and drop for text editors.
    function setupDnDForEditors(){
      // 1) Local DnD on ACE container.
      const el = document.getElementById('aceText');
      if (el){
        ['dragenter','dragover'].forEach(ev=>{
          el.addEventListener(ev, (e)=>{
            if (window.__FM_ACTIVE) return;           // FM open -> ignore.
            if (projectMode === 'text'){
              e.preventDefault();
              if (e.dataTransfer) e.dataTransfer.dropEffect = 'copy';
            }
          }, false);
        });
        el.addEventListener('drop', (e)=>{
          if (window.__FM_ACTIVE) {                   // FM open -> swallow.
            e.preventDefault(); e.stopPropagation();
            return;
          }
          if (projectMode !== 'text') return;
          e.preventDefault();
          e.stopPropagation();
          if (typeof hideDropZone === 'function') try { hideDropZone(); } catch(_){}
          handleTextDrop(e);
        }, false);
      }

      // 2) Global capture: block Blockly DnD when text is active,
      // and if FM is open, block all outside (openFM handles overlay).
      const capDragOver = (e)=>{
        if (window.__FM_ACTIVE) return;               // openFM already blocks outside overlay.
        if (projectMode === 'text' &&
            e.dataTransfer && e.dataTransfer.types && e.dataTransfer.types.includes('Files')){
          e.preventDefault();
          e.stopPropagation();                        // Stop propagation to Blockly.
          e.dataTransfer.dropEffect = 'copy';
        }
      };
      const capDrop = (e)=>{
        if (window.__FM_ACTIVE) return;               // openFM already blocks outside overlay.
        if (projectMode === 'text'){
          if (e.dataTransfer && e.dataTransfer.files && e.dataTransfer.files.length){
            e.preventDefault();
            e.stopPropagation();
            if (typeof hideDropZone === 'function') try { hideDropZone(); } catch(_){}
            handleTextDrop(e);
          } else {
            e.preventDefault();
            e.stopPropagation();
          }
        }
      };
      document.addEventListener('dragover', capDragOver, true); // capture
      document.addEventListener('drop',     capDrop,     true); // capture
    }



    // Save the current project to the PC.
    function saveCurrentProjectToPC(){
      if (projectMode === 'text'){
        // Prefer existing implementation if present.
        if (typeof saveActiveTabAsFile === 'function'){
          return saveActiveTabAsFile();
        }
        // Fallback: download active tab content.
        if (!textProject || textProject.activeIndex < 0 || !textProject.files.length){
          return show_modal_message && show_modal_message(t('dialogs.nothingToSaveTitle'), t('dialogs.noTabOpen'));
        }
        const f = textProject.files[textProject.activeIndex];
        const name = (f && f.name) ? f.name : t('textProject.defaultFileName');
        const content = f.session ? f.session.getValue() : (f.content || '');

        const blob = new Blob([content], {type: 'text/plain;charset=utf-8'});
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = name;
        document.body.appendChild(a);
        a.click();
        URL.revokeObjectURL(a.href);
        document.body.removeChild(a);
      } else {
        // Blockly: unchanged -> download project to PC
        // (reuse existing export)
        if (typeof save_file_dialog === 'function') return save_file_dialog(); // calls code_download_pc()
        if (typeof code_download_pc === 'function')  return code_download_pc();
      }
    }







    // Open a project based on the current mode.
    function openCurrentProject(){
      if (projectMode==="blocks") code_upload_pc();
      else openFileIntoActiveTab();
    }

    // Save the current project based on the current mode.
    function saveCurrentProject(){
      if (projectMode === "blocks"){
        // Blocks: open the save dialog for PC.
        save_file_dialog(); // calls code_download_pc()
      } else {
        // Text: save active tab to ESP using the tab name.
        saveActiveTabToESP();
      }
    }

    const SHARE_SAVE_URL = "https://espide.eu/share/share_save.php";
    const SHARE_LOAD_URL = "https://espide.eu/share/share_load.php";
    const SHARE_ID_RE = /^[A-Z0-9]{6}$/;

    function getActiveShareTextFile() {
      if (!textProject || textProject.activeIndex < 0 || !textProject.files.length) {
        throw new Error(t('dialogs.noTabOpen'));
      }
      const f = textProject.files[textProject.activeIndex];
      const name = (f && f.name) ? f.name : t('textProject.defaultFileName');
      const content = f.session ? f.session.getValue() : (f.content || '');
      return { name, content };
    }

    function buildSharePayload() {
      const mode = (projectMode === "text") ? "text" : "blocks";
      const meta = {
        mode,
        processor: (userSettings && userSettings.processor) ? userSettings.processor : null,
        timestamp: new Date().toISOString()
      };

      if (mode === "blocks") {
        if (!window.Blockly || !window.demoWorkspace) {
          throw new Error(t('share.invalidProject'));
        }
        const xml = Blockly.Xml.workspaceToDom(demoWorkspace);
        const xmlText = Blockly.Xml.domToText(xml);

        let used = [];
        try { used = pickUsedExtensions(xmlText) || []; } catch (_) { used = []; }

        meta.extensions = used;
        meta.projectName = (document.getElementById("save_filename")?.value || "").trim();

        const payload = { version: 1, processor: meta.processor, extensions: used };
        const blob = utf8_to_b64(JSON.stringify(payload));
        const finalText = injectExtensionsIntoXml(xmlText, blob);

        return { code: finalText, lang: "blocks", meta };
      }

      const active = getActiveShareTextFile();
      meta.filename = active.name;
      meta.extensions = [];

      return { code: active.content, lang: "text", meta };
    }

    async function safeCopyText(text) {
      if (navigator.clipboard && navigator.clipboard.writeText) {
        return navigator.clipboard.writeText(text);
      }
      const ta = document.createElement("textarea");
      ta.value = text;
      ta.setAttribute("readonly", "readonly");
      ta.style.position = "fixed";
      ta.style.left = "-9999px";
      document.body.appendChild(ta);
      ta.select();
      try { document.execCommand("copy"); } finally { document.body.removeChild(ta); }
    }

    function showShareResult(id) {
      //const base = (location && location.origin) ? location.origin.replace(/\/$/, "") : "";
      const base = "https://espide.eu" // Forced URL to https://espide.eu
	  const shareUrl = base ? `${base}/${id}` : `https://espide.eu/${id}`;
      const html = `
        <div style="text-align:left;">
          <div style="font-size:16px; opacity:.8; margin-bottom:-2px;">${t('share.codeLabel')}</div>
          <div style="display:flex; gap:8px; align-items:center; margin-bottom:0px;">
            <input id="shareCodeField" value="${id}" readonly
                   style="flex:1; padding:8px; border:1px solid var(--ui-border); border-radius:6px; background: var(--ui-bg-input); color: var(--ui-text);">
            <button type="button" id="shareCopyCodeBtn"
                    style="padding:8px 10px; border:1px solid var(--ui-border); border-radius:6px; background: var(--button-bg); color: var(--button-text); cursor:pointer;">
              ${t('share.copyCode')}
            </button>
          </div>
          <div style="font-size:16px; opacity:.8; margin-bottom:-2px;">${t('share.urlLabel')}</div>
          <div style="display:flex; gap:8px; align-items:center;">
            <input id="shareUrlField" value="${shareUrl}" readonly
                   style="flex:1; padding:8px; border:1px solid var(--ui-border); border-radius:6px; background: var(--ui-bg-input); color: var(--ui-text);">
            <button type="button" id="shareCopyUrlBtn"
                    style="padding:8px 10px; border:1px solid var(--ui-border); border-radius:6px; background: var(--button-bg); color: var(--button-text); cursor:pointer;">
              ${t('share.copyUrl')}
            </button>
          </div>
        </div>`;

      Swal.fire({
        title: t('share.resultTitle'),
        icon: "success",
        html,
        width: 460,
        confirmButtonText: t('actions.close'),
        didOpen: () => {
          const codeBtn = Swal.getPopup().querySelector("#shareCopyCodeBtn");
          const urlBtn = Swal.getPopup().querySelector("#shareCopyUrlBtn");
          if (codeBtn) {
            codeBtn.addEventListener("click", async () => {
              await safeCopyText(id);
              codeBtn.textContent = t('share.copied');
              setTimeout(() => { codeBtn.textContent = t('share.copyCode'); }, 1200);
            });
          }
          if (urlBtn) {
            urlBtn.addEventListener("click", async () => {
              await safeCopyText(shareUrl);
              urlBtn.textContent = t('share.copied');
              setTimeout(() => { urlBtn.textContent = t('share.copyUrl'); }, 1200);
            });
          }
        }
      });
    }

    async function shareCurrentProject() {
      let payload;
      try {
        payload = buildSharePayload();
      } catch (e) {
        Swal.fire(t('errors.title'), String(e && e.message || e), "error");
        return;
      }

      Swal.fire({
        title: t('share.savingTitle'),
        html: t('share.savingBody'),
        allowOutsideClick: false,
        didOpen: () => { Swal.showLoading(); }
      });

      try {
        const res = await fetch(SHARE_SAVE_URL, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload)
        });
        const data = await res.json().catch(() => ({}));
        if (!res.ok || !data || !data.ok) {
          throw new Error(data && data.error ? data.error : `HTTP ${res.status}`);
        }
        const id = String(data.id || "").toUpperCase();
        if (!SHARE_ID_RE.test(id)) throw new Error(t('share.invalidId'));
        Swal.close();
        showShareResult(id);
      } catch (e) {
        Swal.close();
        Swal.fire(t('errors.title'), t('share.error', { error: String(e && e.message || e) }), "error");
      }
    }

    function normalizeShareCode(value) {
      return String(value || "").trim().toUpperCase();
    }

    async function loadShareByCode(code) {
      const res = await fetch(`${SHARE_LOAD_URL}?id=${encodeURIComponent(code)}`, { cache: "no-store" });
      const data = await res.json().catch(() => null);
      if (!res.ok || !data) {
        throw new Error(data && data.error ? data.error : `HTTP ${res.status}`);
      }
      await applySharedPayload(data, code);
    }

    async function applySharedPayload(data, code) {
      if (!data || typeof data !== "object") throw new Error(t('share.loadInvalidPayload'));
      const lang = String(data.lang || "").toLowerCase();
      const content = (typeof data.code === "string") ? data.code : "";
      if (!content) throw new Error(t('share.loadInvalidPayload'));

      if (lang === "blocks") {
        if (typeof window.__espideFM_openBlocksFromString === "function") {
          await window.__espideFM_openBlocksFromString(content, `share_${code || "project"}.blk`);
          return;
        }
      }

      if (lang === "text") {
        const metaName = (data.meta && typeof data.meta.filename === "string") ? data.meta.filename.trim() : "";
        const name = metaName || `share_${code || "file"}.txt`;
        if (typeof window.__espideFM_openTextTab === "function") {
          window.__espideFM_openTextTab(name.replace(/^\/+/, ""), content);
          return;
        }
      }

      throw new Error(t('share.loadInvalidPayload'));
    }

    function openShareLoadDialog() {
      const html = `
        <div style="text-align:left;">
          <div style="font-size:16px; opacity:.8; margin-bottom:-2px;">${t('share.codeLabel')}</div>
          <input id="shareLoadCode" type="text" maxlength="6" autocomplete="off"
                 placeholder="${t('share.codePlaceholder')}"
                 style="width:95%; padding:10px; border:1px solid var(--ui-border); border-radius:6px; background: var(--ui-bg-input); color: var(--ui-text);">
        </div>`;

      Swal.fire({
        title: t('share.loadTitle'),
        html,
        showCancelButton: true,
        confirmButtonText: t('share.loadAction'),
        cancelButtonText: t('actions.close'),
        focusConfirm: false,
        showLoaderOnConfirm: true,
        allowOutsideClick: () => !Swal.isLoading(),
        preConfirm: async () => {
          const input = Swal.getPopup().querySelector("#shareLoadCode");
          const code = normalizeShareCode(input ? input.value : "");
          if (!SHARE_ID_RE.test(code)) {
            Swal.showValidationMessage(t('share.loadInvalid'));
            return false;
          }

          try {
            await loadShareByCode(code);
            return code;
          } catch (e) {
            Swal.showValidationMessage(t('share.loadError', { error: String(e && e.message || e) }));
            return false;
          }
        },
        didOpen: () => {
          const input = Swal.getPopup().querySelector("#shareLoadCode");
          if (input) {
            input.addEventListener("input", () => {
              input.value = normalizeShareCode(input.value).replace(/[^A-Z0-9]/g, "");
            });
            input.focus();
          }
        }
      });
    }

    function getShareCodeFromUrl() {
      const params = new URLSearchParams(window.location.search || "");
      let code = normalizeShareCode(params.get("share") || params.get("id") || params.get("code") || "");
      if (SHARE_ID_RE.test(code)) return code;

      const path = (window.location.pathname || "").replace(/\/+$/, "");
      const last = path.split("/").filter(Boolean).pop() || "";
      code = normalizeShareCode(last);
      return SHARE_ID_RE.test(code) ? code : "";
    }

    function waitForIdeReady(timeoutMs = 15000) {
      return new Promise((resolve, reject) => {
        const start = Date.now();
        (function check() {
          const ready = typeof window.Blockly !== "undefined" && window.demoWorkspace;
          if (ready) {
            resolve();
            return;
          }
          if (Date.now() - start >= timeoutMs) {
            reject(new Error("IDE not ready."));
            return;
          }
          setTimeout(check, 100);
        })();
      });
    }

    async function autoLoadShareFromUrl() {
      const code = getShareCodeFromUrl();
      if (!code || window.__espideShareAutoLoaded === code) return;
      window.__espideShareAutoLoaded = code;
      try {
        Swal.fire({
          title: t('share.loadTitle'),
          allowOutsideClick: false,
          didOpen: () => { Swal.showLoading(); }
        });
        await waitForIdeReady();
        await loadShareByCode(code);
        Swal.close();
      } catch (e) {
        Swal.close();
        Swal.fire(t('errors.title'), t('share.loadError', { error: String(e && e.message || e) }), "error");
      }
    }

    window.addEventListener("load", () => {
      autoLoadShareFromUrl();
    });




    // Undo action from the top bar.
    function topbarUndo(){
      if (projectMode === "text"){
        try {
          if (aceText && typeof aceText.undo === 'function') aceText.undo();
          else {
            const i = textProject.activeIndex;
            const ses = i>=0 && textProject.files[i] && textProject.files[i].session;
            if (ses && ses.getUndoManager) ses.getUndoManager().undo(false);
          }
        } catch(_) {}
      } else {
        if (window.Blockly && Blockly.mainWorkspace) Blockly.mainWorkspace.undo(false);
      }
    }

    // Redo action from the top bar.
    function topbarRedo(){
      if (projectMode === "text"){
        try {
          if (aceText && typeof aceText.redo === 'function') aceText.redo();
          else {
            const i = textProject.activeIndex;
            const ses = i>=0 && textProject.files[i] && textProject.files[i].session;
            if (ses && ses.getUndoManager) ses.getUndoManager().redo(false);
          }
        } catch(_) {}
      } else {
        if (window.Blockly && Blockly.mainWorkspace) Blockly.mainWorkspace.undo(true);
      }
    }







    // Open a text file in ACE as a new tab (devicePath can include folders).
    window.__espideFM_openTextTab = function(devicePath, content){
      try{
        const rbBlocks = document.getElementById('modeBlocks');
        const rbText   = document.getElementById('modeText');
        rbBlocks.checked = false;
        rbText.checked = true;
        switchUITo("text");

        // Create a tab via "exact" helper to preserve "/" in names.
        addNewTabExact(devicePath.replace(/^\/+/, ''), content);

        // Focus editor.
        if (typeof aceText !== 'undefined' && aceText) aceText.focus();
      }catch(e){
        if (typeof show_modal_message === 'function') show_modal_message(t('errors.fileOpenFailedTitle'), String(e && e.message || e));
      }
    };


    // Open XML/BLK in Blockly (includes extensions and processor switch).
    window.__espideFM_openBlocksFromString = async function(xmlOrBlkText, filename){
      try{
        const rbBlocks = document.getElementById('modeBlocks');
        const rbText   = document.getElementById('modeText');
        rbBlocks.checked = true;
        rbText.checked = false;
        switchUITo("blocks");

        // Minimal fallback.
        var blocks = document.getElementById('blocklyDiv');
        var textPane = document.getElementById('textEditorPane');
        if (blocks) blocks.style.display = 'block';
        if (textPane) textPane.style.display = 'none';
        if (typeof projectMode !== 'undefined') projectMode = 'blocks';



        // Extract extensions blob and switch processor if needed.
        var strippedText = xmlOrBlkText;
        if (typeof peelExtensionsComment === 'function'){
          const { payload, strippedText: st } = peelExtensionsComment(xmlOrBlkText);
          strippedText = st || xmlOrBlkText;

          if (payload && payload.processor && typeof switchProcessorAndReloadToolbox === 'function'){
            if (!window.userSettings || window.userSettings.processor !== payload.processor){
              await switchProcessorAndReloadToolbox(payload.processor);
            }
          }
          if (payload && payload.extensions && Array.isArray(payload.extensions) && typeof mergeAndIntegrateExtensionsFromPayload === 'function'){
            mergeAndIntegrateExtensionsFromPayload(payload);
          }
        }

        // Load into workspace.
        const xml = Blockly.Xml.textToDom(strippedText);
        if (typeof demoWorkspace !== 'undefined' && demoWorkspace){
          demoWorkspace.clear();
          Blockly.Xml.domToWorkspace(xml, demoWorkspace);
        }
      }catch(err){
        if (typeof show_modal_message === 'function') show_modal_message(t('errors.projectLoadFailedTitle'), String(err && err.message || err));
      }
    };


    // Create a new tab with exact name (including "/") and handle collisions.
    function addNewTabExact(exactName, initialText){
      if (typeof textProject === 'undefined') window.textProject = { files: [], activeIndex: -1 };

      // If a tab with the same name exists, reuse it.
      const idx = (textProject.files || []).findIndex(f => f && f.name === exactName);
      if (idx >= 0){
        const f = textProject.files[idx];
        if (f && f.session) f.session.setValue(String(initialText || ''));
        textProject.activeIndex = idx;
        if (typeof renderTabs === 'function') renderTabs();
        if (typeof aceText !== 'undefined' && aceText && f && f.session) aceText.setSession(f.session);
        return;
      }

      // New session.
      const ses = typeof AceEditSession !== 'undefined'
          ? new AceEditSession(String(initialText || ''))
          : (ace && ace.createEditSession ? ace.createEditSession(String(initialText || '')) : null);

      if (!ses) throw new Error('ACE session is unavailable.');

      // Try to set mode by extension.
      (function(){
        const m = (exactName.split('.').pop() || '').toLowerCase();
        let mode = null;
        if (m === 'py') mode = 'ace/mode/python';
        else if (m === 'js') mode = 'ace/mode/javascript';
        else if (m === 'json') mode = 'ace/mode/json';
        else if (m === 'html' || m === 'htm') mode = 'ace/mode/html';
        else if (m === 'css') mode = 'ace/mode/css';
        if (mode && ses.setMode) ses.setMode(mode);
      })();

      // Undo manager to keep Ctrl+Z/Undo working for these tabs.
      try{
        const um = (typeof AceUndoManager !== 'undefined') ? new AceUndoManager()
                  : (ace && ace.require ? ace.require('ace/undomanager').UndoManager : null);
        if (um && ses.setUndoManager) ses.setUndoManager(um);
      }catch(_){}

      // Persist into project.
      textProject.files = Array.isArray(textProject.files) ? textProject.files : [];
      textProject.files.push({ name: exactName, session: ses, dirty: false });
      textProject.activeIndex = textProject.files.length - 1;

      // Attach to ACE.
      if (typeof aceText !== 'undefined' && aceText && ses) aceText.setSession(ses);
      if (typeof renderTabs === 'function') renderTabs();
      if (typeof saveTextProjectToLS === 'function') saveTextProjectToLS();
    }










  </script>
  <title>ESP IDE</title>
  <style type="text/css" media="screen">
    :root {
      --ui-bg: #f6f6f6;
      --ui-bg-soft: #e6e6e6;
      --ui-bg-panel: #f6f6f6;
      --ui-bg-elevated: #ffffff;
      --ui-bg-input: #fafafa;
      --ui-border: #a8a8a8;
      --ui-border-soft: #d0d7de;
      --ui-text: #1f2328;
      --ui-text-muted: #4b5563;
      --ui-accent: #3f51b5;
      --ui-accent-contrast: #ffffff;
      --ui-hover: #e5e7eb;
      --ui-shadow: rgba(0, 0, 0, 0.4);
      --toolbox-bg: #f6f6f6;
      --toolbox-flyout-bg: #f6f6f6;
      --toolbox-text: #1f2328;
      --toolbox-hover: #ebebeb;
      --toolbox-selected: #d4d4d4;
      --workspace-bg: #ffffff;
      --workspace-stroke: #c6c6c6;
      --button-bg: #f6f6f6;
      --button-border: #a8a8a8;
      --button-hover: #e5e5e5;
      --button-text: #1f2328;
      --tab-bg: #ffffff;
      --tab-border: #a5a5a5;
      --tab-active-outline: #b9b9b9;
      --terminal-bg: #000000;
      --terminal-border: #000000;
      --dialog-bg: #ffffff;
      --dialog-border: #666666;
      --loading-bg: #f6f6f6;
      --loading-ring: #3f51b5;
      --loading-ring-track: rgba(63, 81, 181, 0.2);
      --topbar-bg: #f6f6f6;
      --theme-color: #f6f6f6;
    }

    html.theme-dark {
      color-scheme: dark;
      --ui-bg: #131821;
      --ui-bg-soft: #2c333d;
      --ui-bg-panel: #131821;
      --ui-bg-elevated: #475971;
      --ui-bg-input: #0f141a;
      --ui-border: #2d333b;
      --ui-border-soft: #3a414c;
      --ui-text: #e6edf3;
      --ui-text-muted: #9aa4af;
      --ui-accent: #5f5f5f;
      --ui-accent-contrast: #0b0d10;
      --ui-hover: #202836;
      --ui-shadow: rgba(0, 0, 0, 0.6);
      --toolbox-bg: #131821;
      --toolbox-flyout-bg: #11161d;
      --toolbox-text: #e6edf3;
      --toolbox-hover: #1e2734;
      --toolbox-selected: #2a3a52;
      --workspace-bg: #0b0f14;
      --workspace-stroke: #2a3340;
      --button-bg: #1b222c;
      --button-border: #2a3340;
      --button-hover: #263043;
      --button-text: #e6edf3;
      --tab-bg: #151c25;
      --tab-border: #2a3340;
      --tab-active-outline: #3a4a62;
      --terminal-bg: #0b0d10;
      --terminal-border: #1a212b;
      --dialog-bg: #161c24;
      --dialog-border: #394352;
      --loading-bg: #0b0f14;
      --loading-ring: #6ea8ff;
      --loading-ring-track: rgba(110, 168, 255, 0.25);
      --topbar-bg: #131821;
      --theme-color: #0b0f14;
    }

    html, body { height: 100%; }
    body {
      overflow: hidden;
      margin: 0;
      padding: 0px;
      background-color: var(--ui-bg);
      color: var(--ui-text);
      box-sizing: border-box;
    }

    @font-face {
      font-family: "JetBrainsMono";
      src: url("media/font.woff2") format("woff2");
      font-weight: 400;
      font-style: normal;
    }


    a { color: var(--ui-accent); }
    .ace_editor {
      margin: 0;
      position: relative;
      top: 0; bottom: 0; left: 0; right: 0;
      height: 100%;
      width: 100%;
    }

    /* Vynucení monospace jen pro Ace */
    .ace_editor,
    .ace_editor * {
      font-family: "JetBrainsMono", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,
                  "Liberation Mono", "Courier New", monospace !important;
      font-variant-ligatures: none; /* volitelné */
    }

    #term {
      margin: 0;
      position: relative;
      top: 0; bottom: 0; left: 0; right: 0;
      background: var(--terminal-bg);
      height: 100%;
      width: 100%;
    }
    .terminal { border: var(--terminal-border) solid 2px; background: var(--terminal-bg); }
    .x, .x_code, #save_dialog_btn, #load_dialog_btn { cursor: pointer; }
    .split {
      -webkit-box-sizing: border-box;
      -moz-box-sizing: border-box;
      box-sizing: border-box;
      overflow-y: auto;
      overflow-x: hidden;
    }
    .content { border: 0px solid #C0C0C0; }

    .gutter { background-color: var(--ui-border); }
    .gutter.gutter-vertical { cursor: row-resize; }
    #editor_div { padding-top: 44px; }

    #terminal_div {
      position: absolute;
      width: 100%;
    }

    #more_button  {
      position: absolute;
      top: 0px;
      right: 0px;
      height: 43px;
      width: 42px;
      background: var(--topbar-bg);
      display: block;
      text-align: center;
      cursor: pointer;
      line-height: 44px;
      font-size: 30px;
      color: var(--ui-text);
      caret-color: transparent;
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      -khtml-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
      transition: background-color 0.15s ease, box-shadow 0.15s ease, transform 0.1s ease;
      border-radius: 8px;
    }
    #more_button:hover {
      background: var(--ui-bg-soft);
      box-shadow: 0 0 0 1px var(--ui-border), 0 4px 10px rgba(0,0,0,0.12);
    }
    #more_button:active {
      transform: translateY(1px);
    }
    #more_button:focus-visible {
      outline: 2px solid var(--ui-border);
      outline-offset: 2px;
    }
    #more_menu  {
      position: absolute;
      top: 48px;
      right: 3px;
      height: 656px;
      width: 200px;
      background: var(--ui-bg-panel);
      cursor: default;
      text-align: left;
      font-size: 15px;
      font-family: Geneva, sans-serif;
      border: 1px solid var(--ui-border);
      color: var(--ui-text);
      display: none;
      border-radius: 4px;
      box-shadow: var(--ui-shadow) 0px 3px 8px;
	  z-index: 1000;
    }
    #code_dialog  {
      position: absolute;
      top: 56px;
      right: 20px;
      height: 70%;
      left: 50px;
      background: var(--ui-bg-soft);
      border-radius: 2px;
      box-shadow: var(--ui-shadow) 0px 3px 8px;
      border: 1px solid var(--ui-border-soft);
      display: none;
    }
    #save_dialog  {
      position: absolute;
      top: 70px;
      left: 210px;
      height: 140px;
      width: 250px;
      background: var(--ui-bg-soft);
      border-radius: 6px;
      border: 1px solid var(--ui-border);
      display: none;
      box-shadow: var(--ui-shadow) 0px 3px 8px;
    }
    input, select {
      display: block;
      border: 1px solid var(--ui-border);
      border-radius: 5px;
      font-size: 16px;
      background: var(--ui-bg-input);
      color: var(--ui-text);
      width: 90%;
      padding: 10px;
      margin: 10px;
      -webkit-box-sizing: border-box;
      -moz-box-sizing: border-box;
      box-sizing: border-box;
    }
    .x {
      display: block;
      position: absolute;
      right: 0;
      top: 0;
      width: 32px;
      height: 24px;
      text-align: center;
      font-family: Arial, sans-serif;
      color: var(--ui-text);
    }
    .x_code {
      display: block;
      position: absolute;
      right: 14px;
      top: 0;
      width: 28px;
      height: 24px;
      text-align: center;
      font-family: Arial, sans-serif;
      z-index: 3;
      font-size: x-large;
      color: var(--ui-text);
    }
    #blocklyDiv { height: 100%; width: 100%; position: absolute; background-color: var(--workspace-bg); }
    .blocklyToolboxContents { padding: .1em; }
    .blocklyTreeRow { padding: 10px; margin-bottom: .2em; height:20px; border-radius: 5px; color: var(--toolbox-text); }
    .blocklyToolboxDiv .blocklyTreeRow:hover { background-color: var(--toolbox-hover) !important; }
    .blocklyToolboxDiv .blocklyTreeRow.blocklyTreeSelected,
    .blocklyToolboxDiv .blocklyTreeRow.blocklyTreeSelected:hover { background-color: var(--toolbox-selected) !important; }
    .blocklyToolboxDiv .blocklyTreeRowContentContainer { display: flex; align-items: center; }
    .blocklyTreeLabel { color: var(--toolbox-text) !important; }
    .blocklyToolboxDiv .blocklyTreeLabel { color: var(--toolbox-text) !important; }
    .blocklyFlyoutLabelText { fill: var(--toolbox-text) !important; }
    .blocklyFlyoutLabelText tspan { fill: var(--toolbox-text) !important; }
    .blocklyFlyoutBackground { fill: var(--toolbox-flyout-bg); }
    .blocklyToolboxDiv { background-color: var(--toolbox-bg); }
    .blocklySvg { background-color: var(--workspace-bg); }
    .blocklyMainBackground,
    .blocklyWorkspaceBackground {
      fill: var(--workspace-bg) !important;
      stroke-width: 1;
      stroke: var(--workspace-stroke);
    }
    .blocklyScrollbarBackground { fill: var(--ui-bg-soft); }
    .blocklyScrollbarHandle { fill: var(--ui-border); }
    .blocklyTooltipDiv {
      background: var(--ui-bg-elevated);
      color: var(--ui-text);
      border: 1px solid var(--ui-border);
    }
    .blocklyContextMenu {
      background: var(--ui-bg-elevated);
      color: var(--ui-text);
      border: 1px solid var(--ui-border);
      box-shadow: var(--ui-shadow) 0px 3px 8px;
    }
    .blocklyDropDownDiv {
      background: var(--ui-bg-elevated) !important;
      border: 1px solid var(--ui-border) !important;
      color: var(--ui-text) !important;
      box-shadow: var(--ui-shadow) 0px 3px 8px;
    }
    .blocklyDropDownDiv .blocklyDropDownContent {
      background: transparent !important;
      color: var(--ui-text) !important;
    }
    .blocklyDropDownDiv .blocklyDropdownText {
      fill: var(--ui-text) !important;
    }
    .blocklyDropDownDiv .blocklyMenuItem { color: var(--ui-text) !important; }
    .blocklyDropDownDiv .blocklyMenuItem:hover { background: var(--ui-hover) !important; }
    .blocklyWidgetDiv .blocklyMenu {
      background: var(--ui-bg-elevated) !important;
      color: var(--ui-text);
      border: 1px solid var(--ui-border);
      box-shadow: var(--ui-shadow) 0px 3px 8px;
    }
    .blocklyWidgetDiv .blocklyMenuItem { color: var(--ui-text); }
    .blocklyWidgetDiv .blocklyMenuItem:hover { background: var(--ui-hover); }
    .blocklyMutatorBackground {
      fill: var(--ui-bg-elevated) !important;
      stroke: var(--ui-border) !important;
      stroke-width: 1;
    }
    .blocklyCommentTextarea {
      background-color: var(--ui-bg-input) !important;
      color: var(--ui-text) !important;
      border: 1px solid var(--ui-border) !important;
      outline: 0;
      margin: 0;
      padding: 3px;
      resize: none;
      display: block;
      text-overflow: hidden;
    }
    .blocklyMenuItem { color: var(--ui-text); }
    .blocklyMenuItem:hover { background: var(--ui-hover); }
    .blocklyTreeIcon { width: 1px; }
    .blocklyToolboxDiv .category-icon {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 20px;
      height: 20px;
      margin-right: 2px;
      margin-left: 3px;
      color: inherit;
      flex: 0 0 auto;
    }
    .blocklyToolboxDiv .category-icon svg {
      width: 20px;
      height: 20px;
      display: block;
    }


    #myProgress {
      position: fixed;
      top: 0;
      left: 0;
      width: 0%;
      height: 4px;
      background-color: #29d;
      z-index: 9999;
      transition: width 0.5s ease, opacity 0.2s ease;
    }

    input::placeholder { color: var(--ui-text-muted); }
    input[type="checkbox"] { accent-color: var(--ui-accent); }
    button, input[type="button"], input[type="submit"] {
      background: var(--button-bg);
      border: 1px solid var(--button-border);
      color: var(--button-text);
      cursor: pointer;
    }
    button:hover, input[type="button"]:hover, input[type="submit"]:hover {
      background: var(--button-hover);
    }
    #SerialConnectButton, #BLE_SerialConnectButton {
      background-color: var(--topbar-bg) !important;
      border: none !important;
    }
    #gamepadToggle {
      background-color: transparent !important;
      border: 0 !important;
    }
    #processorDropdown {
      background: var(--ui-bg-input);
      color: var(--ui-text);
      border: 1px solid var(--ui-border);
    }
    #more_menu hr {
      border: 0;
      border-top: 1px solid var(--ui-border-soft);
      margin: 8px 4px;
    }
    #more_menu button {
      background: var(--button-bg);
      color: var(--button-text);
      border: 1px solid var(--button-border);
      cursor: pointer;
    }
    #more_menu button:hover { background: var(--button-hover) !important; }
    #more_menu input[type="checkbox"],
    #more_menu label { cursor: pointer; }
    #code_dialog, #save_dialog, #extensions_dialog, #more_menu, #quick_panel, #tabbar {
      color: var(--ui-text);
    }
    #menuVersionLink { color: var(--ui-accent); }
    #tabbar {
      background: var(--ui-bg-panel) !important;
      border-bottom: 1px solid var(--ui-border-soft) !important;
    }
    #btnNewTab {
      background: var(--button-bg) !important;
      border: 1px solid var(--button-border) !important;
      color: var(--button-text) !important;
    }
    #tabs .tab-pill {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 6px 10px;
      border: 1px solid var(--tab-border);
      border-radius: 8px;
      background: var(--tab-bg);
      color: var(--ui-text);
      cursor: pointer;
      height: 21px;
      margin: 4px;
    }
    #tabs .tab-pill.is-active {
      outline: 3px solid var(--tab-active-outline);
    }


    /* Safe SweetAlert2 behavior with custom layout */
    html.swal2-shown, body.swal2-shown { overflow: initial !important; }
    body.swal2-height-auto { height: auto !important; }

    /* Render into #swal-root above everything, without a global backdrop */
    #swal-root { position: fixed; inset: 0; z-index: 2147483647; pointer-events: none; }
    #swal-root .swal2-container { pointer-events: all; }
    #swal-root .swal2-popup {
      background: var(--dialog-bg);
      color: var(--ui-text);
      border: 1px solid var(--dialog-border);
    }
    #swal-root .swal2-title,
    #swal-root .swal2-html-container { color: var(--ui-text); }
    #swal-root .swal2-input,
    #swal-root .swal2-textarea,
    #swal-root .swal2-select {
      background: var(--ui-bg-input);
      color: var(--ui-text);
      border: 1px solid var(--ui-border);
    }
    #swal-root .swal2-styled.swal2-confirm,
    #swal-root .swal2-styled.swal2-cancel {
      background: var(--button-bg);
      color: var(--button-text);
      border: 1px solid var(--button-border);
      box-shadow: none;
    }
    #swal-root .swal2-styled.swal2-confirm:hover,
    #swal-root .swal2-styled.swal2-cancel:hover {
      background: var(--button-hover);
    }

  </style>


  <style>
    #extensions_dialog {
      position: absolute;
      z-index: 10001;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 340px;
      height: 500px;
      background: var(--dialog-bg);
      border: 2px solid var(--dialog-border);
      border-radius: 6px;
      display: none;
    }
    #ext_header {
      padding: 6px 10px;
      font-size: 18px;
      background: var(--ui-border);
      color: var(--ui-text);
    }
    #ext_list {
      height: 250px;
      overflow: auto;
      padding: 8px;
    }
    #ext_drop {
      height: 90px;
      margin: 8px;
      border: 2px dashed var(--ui-accent);
      border-radius: 6px;
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--ui-accent);
      font-size: 20px;
    }
    #extensions_dialog .ext_row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin: 4px 0;
    }
    .ext_btn {
      margin-left: 6px;
      background: #d84c4c;
      color: #ffffff;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      height: 22px;
    }
    #extensions_dialog .ext_row label {
      flex: 1;
      margin-left: 6px;
      color: var(--ui-text);
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    #extensions_dialog input[type="checkbox"]{
      width:20px;          /* width 24 px */
      height:20px;         /* height 24 px to keep it square */
      cursor:pointer;
      /* optional: checkmark color in modern browsers */
      accent-color: var(--ui-accent);
    }

    #fileManagerCover {
      position: absolute;
      top: 2px;
      left: 482px;
      width: 36px;
      height: 40px;
      background: var(--topbar-bg);
      display: none;
      z-index: 1001;
      cursor: default;
    }










    .segmented {
      display: inline-flex;
      gap: 0;
      background: var(--ui-bg-soft);
      padding: 2px;
      border-radius: 6px;
      box-shadow: 0 1px 2px rgba(0,0,0,.15) inset, 0 1px 2px rgba(0,0,0,.15);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial;
    }
    .segmented input { display:none; }
    .segmented label {
      padding:3px 4px; border-radius:5px; cursor:pointer; user-select:none;
      border:1px solid transparent; font-size:14px; line-height:18px;
    }
    .segmented input:checked + label {
      background: var(--ui-bg-elevated);
      border-color: var(--ui-border-soft);
      box-shadow: 0 1px 2px rgba(0,0,0,.15);
    }

    #modeSwitch { height:31px; }


    #textShell { position: relative; height:100%; width:100%; }
    #textEditorHost { position:absolute; top:55px; left:0; right:0; bottom:0; }
    #aceText { position:absolute; top:0px; left:0; right:0; bottom:0; }












    :root { --qp-h: 56px; }  /* panel height computed by JS */

    #quick_panel_button{
      position:absolute; top:0; right:44px; width:40px; height:42px;
      background: var(--topbar-bg); display:none;
      color: var(--ui-text);
      text-align:center; line-height:42px; font-size:36px; cursor:pointer;
      user-select:none; z-index:1000;
    }

    /* Panel slides smoothly via height; content sticks to bottom. */
    #quick_panel{
      position:absolute; left:0; right:0; top:44px;
      height:0; overflow:hidden; background: var(--ui-bg-panel); border-bottom:1px solid var(--ui-border-soft);
      transition: height .25s ease;
      box-shadow:0 2px 4px rgba(0,0,0,.06);
      z-index:999;
    }
    #quick_panel.open{ height: var(--qp-h); }

    #quick_panel_inner{
      position:relative; height:100%;
    }

    /* Panel items are absolutely positioned; Y is pinned to bottom. */
    .in-panel{
      position:absolute !important;
      bottom:8px;  /* stick to panel bottom edge */
    }

    /* Breakpoint: narrow screens - show toggle, hide topbar instances (outside panel) */
    @media (max-width:1150px){
      #quick_panel_button{ display:block; }
      #SerialConnectButton:not(.in-panel),
      #BLE_SerialConnectButton:not(.in-panel),
      #processorDropdown:not(.in-panel),
      #modeSwitch:not(.in-panel){ display:none !important; }
    }

    /* Wide screens: hide panel */
    @media (min-width:1151px){
      #quick_panel_button, #quick_panel{ display:none !important; }
    }

    /* Text mode tabs: single line, horizontal scroll, non-selectable text */
    #tabbar{ white-space:nowrap; overflow:hidden; height: 50px;}
    #tabs{
      display:flex; gap:6px;
      flex-wrap:nowrap !important;
      overflow-x:auto; overflow-y:hidden; scrollbar-width:thin;
      height:54px;
    }
    #tabs, #tabs *{ user-select:none; -webkit-user-select:none; }




    #gamepadToggle{
      background: transparent center/contain no-repeat;
      border:0; padding:0; margin:0; outline:0;
      -webkit-appearance:none; appearance:none;
      -webkit-tap-highlight-color: transparent;
      -webkit-user-select:none; user-select:none;
      touch-action: manipulation;
      cursor: pointer;
    }
    #gamepadToggle:focus, #gamepadToggle:focus-visible, #gamepadToggle:active{
      outline:0; box-shadow:none;
    }
    #gamepadToggle::-moz-focus-inner{ border:0; }









    #btnOpenFM{position:absolute; top:8px; right:12px; height:36px; padding:0 12px; z-index:1200;}
    #fm_overlay{position:fixed; inset:0; display:none; z-index:2147483646; background:rgba(0,0,0,0.35); overflow:auto;}
    #fm_mount{ background: var(--dialog-bg) !important; color: var(--ui-text); }

    #loading_screen{
      position: fixed;
      inset: 0;
      z-index: 9000;
      background: var(--loading-bg);
      display: flex;
      align-items: center;
      justify-content: center;
      text-align: center;
      transition: opacity 0.4s ease, transform 0.4s ease;
    }
    #loading_screen.loading-hidden{
      opacity: 0;
      transform: translateY(-12px);
      pointer-events: none;
    }
    .loading_card{
      display: inline-flex;
      flex-direction: column;
      align-items: center;
      gap: 14px;
      color: var(--ui-text);
      font-family: Geneva, sans-serif;
    }
    .loading_logo{
      position: relative;
      width: 120px;
      height: 120px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .loading_logo img{
      width: 72px;
      height: 72px;
      display: block;
    }
    .loading_spinner{
      position: absolute;
      inset: 4px;
      border-radius: 50%;
      border: 4px solid var(--loading-ring-track);
      border-top-color: var(--loading-ring);
      animation: spin 1s linear infinite;
    }
    .loading_text{
      font-size: 16px;
      letter-spacing: 0.4px;
      color: var(--ui-text);
    }
    @keyframes spin{
      from { transform: rotate(0deg); }
      to { transform: rotate(360deg); }
    }
  </style>




</head>
<body>
  <div id="myProgress"></div>
  <div id="loading_screen" aria-live="polite" aria-busy="true">
    <div class="loading_card">
      <div class="loading_logo">
        <img id="loading_logo" data-theme-src="media/icon-192.png" src="media/icon-192.png" alt="ESP IDE">
        <div class="loading_spinner" aria-hidden="true"></div>
      </div>
      <div class="loading_text" data-i18n="loading.startup">Loading...</div>
    </div>
  </div>
  <div id="drop_zone" data-i18n="loading.releaseToLoad" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 9999; display: none; background-color: rgba(0, 0, 0, 0.5); text-align: center; color: white; padding-top: 20%; font-size: 25px;">
    Release to start loading the file.
  </div>

  <img id="topbar_img" data-theme-src="media/topbar_blk.png" src="media/topbar_blk.png" width="520" height="42" usemap="#icon_map" alt="ESP IDE" style="position: absolute; -webkit-user-drag: none; user-select: none; top: 2px; left: 0px">
  <map name="icon_map">
    <area data-i18n-alt="topbar.run" data-i18n-title="topbar.run" alt="Run code" title="Run code" shape="rect" coords="8,1,85,41" onclick="phone_vibrate();runCode();" style="cursor: pointer;">
    <area data-i18n-alt="topbar.stop" data-i18n-title="topbar.stop" alt="Stop program" title="Stop program" shape="rect" coords="94,1,136,41" onclick="phone_vibrate();stopCode();" style="cursor: pointer;">
    <area data-i18n-alt="topbar.openFile" data-i18n-title="topbar.openFile" alt="Open file from PC" title="Open file from PC" shape="rect" coords="145,1,188,41" onclick="phone_vibrate();openCurrentProject();" style="cursor: pointer;">
    <area data-role="save" data-i18n-alt="topbar.saveFile" data-i18n-title="topbar.saveFile" alt="Save file to PC" title="Save file to PC" shape="rect" coords="192,1,234,41" onclick="phone_vibrate();saveCurrentProject();" style="cursor: pointer;">
    <area data-i18n-alt="topbar.undo" data-i18n-title="topbar.undo" alt="Undo"  title="Undo"  shape="rect" coords="240,1,282,41" onclick="phone_vibrate();topbarUndo();"  style="cursor: pointer;">
    <area data-i18n-alt="topbar.redo" data-i18n-title="topbar.redo" alt="Redo" title="Redo" shape="rect" coords="288,1,330,41" onclick="phone_vibrate();topbarRedo();" style="cursor: pointer;">
    <area data-i18n-alt="topbar.showCode" data-i18n-title="topbar.showCode" alt="Show code" title="Show code" shape="rect" coords="336,1,376,41" onclick="phone_vibrate();showCode();" style="cursor: pointer;">
    <area data-i18n-alt="topbar.deviceInfo" data-i18n-title="topbar.deviceInfo" alt="Device info" title="Device info" shape="rect" coords="378,1,423,41" onclick="phone_vibrate();get_Info();" style="cursor: pointer;">
    <area data-i18n-alt="topbar.restartDevice" data-i18n-title="topbar.restartDevice" alt="Restart device" title="Restart device" shape="rect" coords="433,1,472,41" onclick="phone_vibrate();ResetCPU();" style="cursor: pointer;">
    <area id="fileManagerArea" data-i18n-alt="topbar.fileManager" data-i18n-title="topbar.fileManager" alt="File manager" title="File manager" shape="rect" coords="482,1,518,41" onclick="phone_vibrate();openFM();" style="cursor: pointer;">
  </map>
  <div id="fileManagerCover" aria-hidden="true"></div>

  <button id="SerialConnectButton" type="button" title="Connect or disconnect the device via USB" data-i18n-title="buttons.usbConnectTitle" data-i18n-aria-label="buttons.usbConnectTitle" style="position: absolute; border: none; top: 2px; left: 565px; height: 42px; width: 103px; z-index: 999; cursor: pointer; background-color: var(--topbar-bg); background-repeat: no-repeat;  background-size: 103px 42px;">
  </button>


  <button id="BLE_SerialConnectButton" type="button" title="Connect or disconnect the device via Bluetooth" data-i18n-title="buttons.bleConnectTitle" data-i18n-aria-label="buttons.bleConnectTitle" style="position: absolute; border: none; top: 2px; left: 670px; height: 42px; width: 50px; z-index: 999; cursor: pointer; background-color: var(--topbar-bg); background-repeat: no-repeat;  background-size: 50px 42px;">
  </button>



  <!-- Processor selection in the top bar -->
  <select id="processorDropdown" title="Current processor" data-i18n-title="menu.processorTitle" style="position:absolute; top:4px; left:748px; width:160px; height:36px; margin: 0px; padding: 5px; z-index:999; font-size:16px;">
      <option value="ESP32">ESP32</option>
      <option value="ESP32C3">ESP32-C3</option>
      <option value="ESP32S3">ESP32-S3</option>
      <option value="ESP8266">ESP8266</option>
      <option value="RP2040">RP2040</option>
      <option value="RP2040_Picoed">RP2040 Pico:ed</option>
	  <option value="OMG_ESPBit">OMG ESP:Bit</option>
  </select>


  <div id="modeSwitch" class="segmented" style="position:absolute; top:4px; left:930px; z-index:999;">
      <input type="radio" name="mode" id="modeBlocks" checked>
      <label for="modeBlocks" title="Block programming" data-i18n-title="mode.blocksTitle"><img data-theme-src="media/blockly_switch2.png" src="media/blockly_switch2.png" alt="Blocks" data-i18n-alt="mode.blocksAlt" width="67" height="22"></label>
      <input type="radio" name="mode" id="modeText">
      <label for="modeText" title="Text programming" data-i18n-title="mode.textTitle"><img data-theme-src="media/code_switch2.png" src="media/code_switch2.png" alt="Code" data-i18n-alt="mode.textAlt" width="67" height="22"></label>
  </div>







  <div id="editor_div" class="split content">
      <div id="blocklyDiv"></div>

      <!-- Text editor area (hidden by default) -->
      <div id="textShell" style="display:none; height:100%; width:100%; position:relative;">
        <div id="tabbar" style="height:54px; display:flex; align-items:center; gap:6px; padding:2px 8px; background: var(--ui-bg-panel); border-bottom:1px solid var(--ui-border-soft);">
          <button id="btnNewTab" title="New file" data-i18n-title="text.newTabTitle" data-i18n="text.newTab" style="height: 35px; border: 1px solid var(--button-border); border-radius: 8px; background: var(--button-bg); color: var(--button-text); cursor: pointer; padding-right: 15px;margin-bottom: 12px;">+ New</button>
          <div id="tabs" style="display:flex; gap:6px; flex-wrap:wrap;"></div>
        </div>
        <div id="textEditorHost" style="position:absolute; top:58px; left:0; right:0; bottom:0;">
          <div id="aceText" class="ace_editor"></div>
        </div>
      </div>
  </div>


  <div id="terminal_div" class="split content"><div id="term"></div></div>

  <div id="code_dialog" style="z-index: 150;">
    <div class="x_code" onclick="close_code();">x</div>
    <pre id="editor"></pre>
  </div>

  <input id="upload_file_input" type="file" accept=".xml, .blk" style="position: absolute; top: 99%; left: 99%; width: 0px; height: 0px; padding: 0px" />

  <div id="save_dialog" style="z-index: 200;">
    <div class="x" onclick="close_save();">x</div>
    <form class="form_style" action="">
      <p align="center" style="margin: 10px;" data-i18n="dialogs.saveTitle">Save file to PC</p>
      <input type="text" id="save_filename" name="save_filename" value="project_name" placeholder="project_name" data-i18n-value="dialogs.projectNamePlaceholder" data-i18n-placeholder="dialogs.projectNamePlaceholder">
      <input type="submit" id="save_dialog_btn" value="Save" data-i18n-value="dialogs.saveButton" onclick="code_download_pc(); return false;">
    </form>
  </div>




    <div id="extensions_dialog" style="background: var(--dialog-bg);">
        <div id="ext_header">
            <span data-i18n="dialogs.extensionsTitle">Extensions manager</span>
            <span class="x" style="float:right;cursor:pointer;background-color: #d84c4c;color:#fff;margin-right: 2px;margin-top: 4px;border-radius: 4px;" onclick="closeExtensionsDialog()">×</span>
        </div>
        <div id="ext_list"></div>
        <div id="ext_drop" data-i18n="dialogs.extensionsDrop">Drop *.newblk files here</div>
        <input type="file" id="ext_file_input" accept=".newblk" multiple style="display:none">
        <input type="button" id="ext_file_btn" value="Load add-on from PC" data-i18n-value="dialogs.extensionsLoad" style="width:94%;margin:8px 3% 0;height:34px">
        <input type="button" value="Save changes" data-i18n-value="dialogs.extensionsSave" style="width:94%;margin:8px 3%;height:38px" onclick="applyExtensionSelection()">
    </div>



    <div id="quick_panel_button" title="Quick connect and processor selection" data-i18n-title="text.quickPanelTitle">▾</div>
    <div id="quick_panel">
      <div id="quick_panel_inner"></div>
    </div>






    <!-- Virtual gamepad UI -->
    <div id="joyBackdrop" draggable="false" tabindex="-1" style="
      position:fixed; left:0; right:0; bottom:0;
      height:calc(5vh + 315px); background:rgba(65,65,65,0.8);
      z-index:100001; display:none; pointer-events:none;"></div>

    <div id="joy1Div" style="
      position:fixed; bottom:5%; right:3%;
      width:275px; height:275px; z-index:100002; display:none;"></div>

    <div id="joy2Div" style="
      position:fixed; bottom:5%; left:3%;
      width:275px; height:275px; z-index:100002; display:none;"></div>

    <!-- replace the original <img id="gamepadToggle" ...> with this: -->
    <button id="gamepadToggle" type="button" aria-label="Gamepad" data-theme-bg="media/gamepad.png" style="
      position:fixed; bottom:8px; left:50%; transform:translateX(-50%);
      width:100px; height:50px; z-index:100003; display:none;"></button>


  <div id="more_button"
       onclick="showDropdown();"
       title="More options"
       data-i18n-title="menu.moreTitle"
       data-i18n-aria-label="menu.moreTitle"
       role="button"
       aria-label="More options">
       &#x2630;
  </div>
  <div id="more_menu">
    <div>
      <input title="Automatically run after device boot" data-i18n-title="menu.autostartTitle" type="checkbox" id="autostart" name="autostart" onclick="setTimeout(function(){showDropdown()}, 150);" style="margin-right: 5px; width: 28px; height: 28px; vertical-align: -8px; display: inline;">
      <label title="Automatically run after device boot" data-i18n-title="menu.autostartTitle" data-i18n="menu.autostartLabel" for="autostart">Auto-run on boot</label>
    </div>
    <div>
      <input title="Toggle dark mode" data-i18n-title="menu.darkModeTitle" type="checkbox" id="themeToggle" name="themeToggle" style="margin-right: 5px; width: 28px; height: 28px; vertical-align: -8px; display: inline;">
      <label title="Toggle dark mode" data-i18n-title="menu.darkModeTitle" data-i18n="menu.darkModeLabel" for="themeToggle">Dark mode</label>
    </div>
    <div style="margin: 2px 2px; width: 98%; display:flex; align-items:center; gap:8px;">
      <label for="languageSelect" data-i18n="app.languageLabel" style="flex:1;margin-left: 8px;">Language</label>
      <select id="languageSelect" style="flex:1; height:32px; padding:4px;">
        <option value="en" data-i18n="app.languageOptionEn">English</option>
        <option value="cs" data-i18n="app.languageOptionCs">Czech</option>
      </select>
    </div>
    <hr>

    <!-- Open -->
    <button type="button"
            id="menuOpenBtn"
            title="Load a project from PC into the editor"
            data-i18n-title="menu.openProjectTitle"
            data-i18n="menu.openProject"
            onclick="openCurrentProject();showDropdown();"
            style="margin: 2px; width: 98%; height: 42px; vertical-align: middle; display: inline;">
      Open project from PC
    </button>

    <!-- Save -->
    <button type="button"
            id="menuSaveBtn"
            title="Download the current file/project to your PC"
            data-i18n-title="menu.saveProjectTitle"
            data-i18n="menu.saveProject"
            onclick="saveCurrentProjectToPC();showDropdown();"
            style="margin: 2px; width: 98%; height: 42px; vertical-align: middle; display: inline;">
      Save to PC
    </button>

    <hr>

    <!-- Share -->
    <button type="button"
            id="menuShareBtn"
            title="Share the current project online"
            data-i18n-title="menu.shareProjectTitle"
            data-i18n="menu.shareProject"
            onclick="shareCurrentProject();showDropdown();"
            style="margin: 2px; width: 98%; height: 42px; vertical-align: middle; display: inline;">
      Share project
    </button>

    <button type="button"
            id="menuShareLoadBtn"
            title="Load a project by share code"
            data-i18n-title="menu.shareLoadTitle"
            data-i18n="menu.shareLoad"
            onclick="openShareLoadDialog();showDropdown();"
            style="margin: 2px; width: 98%; height: 42px; vertical-align: middle; display: inline;">
      Load shared project
    </button>



    <hr>
    <button id="install_fw-btn" type="button" title="Install firmware to device" data-i18n-title="menu.installFirmwareTitle" data-i18n="menu.installFirmware" onclick="openInstall();showDropdown();" style="margin: 2px; width: 98%; height: 42px; vertical-align: middle; display: inline;">Install firmware to device</button>
    <script>
	// Open the firmware install page in a new tab.
	function openInstall(){
		if (isElectron)
		{
			location.href = 'https://espide.eu/instalace_new/';
		}
		else
		{
			const w = window.open('https://espide.eu/instalace_new/', '_blank', 'noopener');
			if (w) w.opener = null;            // Security.
			else location.href = 'https://espide.eu/instalace_new/'; // Fallback if popup is blocked.
		}
	  }
    </script>


    <hr>
    <button type="button" title="Set block visibility" data-i18n-title="menu.blocksVisibilityTitle" data-i18n="menu.blocksVisibility" onclick="custom_blocks_select();showDropdown();" style="margin: 2px; width: 98%; height: 42px; vertical-align: middle; display: inline;">Set block visibility</button>

    <hr>
    <button type="button" title="Extensions manager" data-i18n-title="menu.extensionsManagerTitle" data-i18n="menu.extensionsManager" onclick="openExtensionsDialog();showDropdown();" style="margin: 2px; width: 98%; height: 42px; vertical-align: middle; display: inline;">Extensions manager</button>

    <hr>
    <button id="joy-btn" type="button" title="Bluetooth joystick app" data-i18n-title="menu.bluetoothJoystickTitle" data-i18n="menu.bluetoothJoystick" onclick="openJoy_App();showDropdown();" style="margin: 2px; width: 98%; height: 42px; vertical-align: middle; display: inline;">Bluetooth joystick app</button>
    <script>
      // Open the Bluetooth joystick app in a new tab.
      function openJoy_App(){
        const lang = (window.__espideI18n && window.__espideI18n.language) || document.documentElement.lang || "en";
        const normalized = String(lang).toLowerCase().startsWith("cs") ? "cs" : "en";
        const url = normalized === "cs" ? "/joy_cs" : "/joy_en";
        const w = window.open(url, '_blank', 'noopener');
        if (w) w.opener = null;            // Security.
        else location.href = url; // Fallback if popup is blocked.
      }
    </script>


    <hr>
    <div style="margin: 2px; width: 98%; text-align: center; font-size: 12px; opacity: .8;">
      <span data-i18n="menu.versionLabel">Version:</span> <a href="javascript:void(0)" onclick="showChangelog()" id="menuVersionLink"><span id="menuVersionText"></span></a>
    </div>
  </div>



  <!-- === File-Manager overlay (lazy load) ================================= -->
  <div id="fm_overlay" style="display:none;position:fixed;inset:0;z-index:99999;background:rgba(0,0,0,0.35);backdrop-filter:saturate(0.8) blur(2px);">
    <div id="fm_mount" style="position:absolute;inset:24px;box-shadow:0 10px 30px rgba(0,0,0,.35);border-radius:18px;overflow:hidden;background:#fff;"></div>
  </div>





  <xml id="toolbox" style="display: none">
    <category name="Loading..." data-i18n-name="text.toolboxLoading" colour="#f6f6f6"></category>
  </xml>

  <script>
    // Progress bar for the loading screen.
    // Run the loading progress animation until window load.
    !function(){
      var t = document.getElementById("myProgress"), e = 25;
      // Advance the bar while loading.
      var n = setInterval(function(){
        if(e < 90){
          e += Math.random()*(200/e);
          if(e > 90) e = 90;
          t.style.width = e + "%";
        }
      }, 500);
      // Finish the bar when the page is fully loaded.
      window.addEventListener("load", function(){
        clearInterval(n);
        t.style.width = "100%";
        setTimeout(function(){ t.style.opacity = 0; }, 500);
      });
    }();
  </script>




  <div id="swal-root"></div>




  <script>
    // Virtual joystick helper for BLE control.
    (() => {
      let joy_X=0, joy_Y=0, joy2_X=0, joy2_Y=0;
      const elIcon = document.getElementById('gamepadToggle');
      const elBg   = document.getElementById('joyBackdrop');
      const elJ1   = document.getElementById('joy1Div');
      const elJ2   = document.getElementById('joy2Div');

      let gp = { open:false, init:false, txTimer:null };

      // Check if BLE joystick is available.
      function haveBleJoy() {
        return typeof isBleConnected === 'function'
            && isBleConnected()
            && typeof mpBLE !== 'undefined'
            && mpBLE && mpBLE.joy;
      }

      // Show or hide the gamepad icon.
      function updateIcon() {
        const show = haveBleJoy();
        elIcon.style.display = show ? 'block' : 'none';
        if (!show) hideGamepad();
      }

      // Create joystick instances on first use.
      function lazyInit() {
        if (gp.init) return;
        gp.init = true;
        // Use fixed sizes to avoid 0 width/height.
        new JoyStick('joy1Div', { width:275, height:275 }, s => { joy_X  = s.x|0; joy_Y  = s.y|0; });
        new JoyStick('joy2Div', { width:275, height:275 }, s => { joy2_X = s.x|0; joy2_Y = s.y|0; });
      }

      // Start sending joystick data on a timer.
      function startTx() {
        stopTx();
        gp.txTimer = setInterval(() => {
          if (!gp.open || !haveBleJoy()) return;
          mpBLE.sendJoy(joy2_X, joy2_Y, joy_X, joy_Y).catch(() => {});
        }, 50);
      }

      // Stop sending joystick data.
      function stopTx() {
        if (gp.txTimer) { clearInterval(gp.txTimer); gp.txTimer = null; }
      }

      // Show the joystick UI and start sending data.
      function showGamepad() {
        if (!haveBleJoy()) return;
        // Show containers first so they have dimensions.
        elBg.style.display = 'block';
        elJ1.style.display = 'block';
        elJ2.style.display = 'block';
        // Suppress flicker.
        elBg.style.visibility = 'hidden';
        elJ1.style.visibility = 'hidden';
        elJ2.style.visibility = 'hidden';

        // Create joysticks after the page renders.
        requestAnimationFrame(() => {
          lazyInit();
          elBg.style.visibility = 'visible';
          elJ1.style.visibility = 'visible';
          elJ2.style.visibility = 'visible';
          gp.open = true;
          startTx();
        });
      }

      // Hide the joystick UI and stop sending data.
      function hideGamepad() {
        gp.open = false;
        elBg.style.display = 'none';
        elJ1.style.display = 'none';
        elJ2.style.display = 'none';
        stopTx();
      }

      // Toggle the joystick UI.
      function toggleGamepad() { gp.open ? hideGamepad() : showGamepad(); }

      // Prevent tap highlight and focus.
      elIcon.addEventListener('pointerdown', e => e.preventDefault());
      elIcon.addEventListener('touchstart', e => { e.preventDefault(); elIcon.blur(); toggleGamepad();}, {passive:false});
      elIcon.addEventListener('click', e => { e.preventDefault(); elIcon.blur(); toggleGamepad(); });

      setInterval(updateIcon, 250);
      updateIcon();

      window.__espideGamepad = { updateIcon, showGamepad, hideGamepad };
    })();
  </script>






  <script>
    // Fallback connection check for older APIs.
    function connectedFallback(){
      if (typeof mp === 'function'){
        try{
          const d = mp();
          return !!d && (d.isConnected || d.connected || d.transportReady);
        }catch(e){ return false; }
      }
      return false;
    }
    // Check if the editor is connected right now.
    function isConnectedNow(){
      if (typeof isEditorConnected === 'function') return !!isEditorConnected();
      return connectedFallback();
    }
    // Show a "not connected" message to the user.
    function showNotConnected(){
      if (typeof show_modal_message === 'function'){
        show_modal_message(t('errors.notConnectedTitle'), t('errors.notConnectedBody'));
      } else {
        alert(`${t('errors.notConnectedTitle')} ${t('errors.notConnectedBody')}`);
      }
    }
    // Load a script file and return a Promise.
    function loadScript(src){
      return new Promise((res,rej)=>{
        const s=document.createElement('script');
        s.src=src; s.defer=false;
        s.onload=()=>res(); s.onerror=()=>rej(new Error('script load failed '+src));
        document.head.appendChild(s);
      });
    }

    // Open the File Manager overlay and load its assets.
    async function openFM(){
      if (!isConnectedNow()){ showNotConnected(); return; }

      await stopCode();

      const overlay = document.getElementById('fm_overlay');
      if (!overlay.dataset.ready){
        // 1) Inject File Manager HTML.
        const full = await (await fetch('filemanager.html',{cache:'no-store'})).text();
        const bodyMatch = full.match(/<body[^>]*>([\s\S]*?)<\/body>/i);
        overlay.innerHTML = bodyMatch ? bodyMatch[1] : full;

        // 2) Add CSS once.
        if (!document.querySelector('link[href="filemanager.css"]')){
          const link = document.createElement('link');
          link.rel='stylesheet'; link.href='css/filemanager.css';
          document.head.appendChild(link);
        }

        // 3) Load filemanager.js (REPL variant inside).
        await loadScript('js/filemanager.js?v=2026-01-29');

        // 4) Listen for close.
        document.addEventListener('click', (e)=>{
          if (e.target && e.target.id === 'fm_close_btn') closeFM();
        });

        overlay.dataset.ready='1';
      }

      overlay.style.display='block';
      // Disable global DnD from index.html, keep FileManager DnD only.
      window.__FM_ACTIVE = true;
      // Global DnD block outside FileManager (capture-level).
      const overlayEl = document.getElementById('fm_overlay');
      const suppressOutsideDnD = (e) => {
      if (!window.__FM_ACTIVE) return;
      // Allow events only inside the overlay.
      if (!overlayEl.contains(e.target)) {
        e.preventDefault();
        e.stopPropagation();
      }
      };
      document.addEventListener('dragover', suppressOutsideDnD, true);
      document.addEventListener('drop',     suppressOutsideDnD, true);
      // Store handler for later removal.
      overlayEl.__suppressOutsideDnD = suppressOutsideDnD;

      try { document.getElementById('drop_zone').style.display = 'none'; } catch(_){}

      // Refresh root after open.
      if (typeof window.loadDirectoryContents === 'function'){
        try{ await loadDirectoryContents('/'); }catch(e){ console.warn(e); }
      }
      if (typeof window.updateStatus === 'function'){
        try{ await updateStatus(); }catch(e){ console.warn(e); }
      }
    }

    // Close the File Manager overlay and clean up.
    function closeFM(){
      document.getElementById('fm_overlay').style.display='none';
      // Re-enable global DnD in index.html.
      const overlayEl = document.getElementById('fm_overlay');
      const h = overlayEl.__suppressOutsideDnD;
      if (h) {
          document.removeEventListener('dragover', h, true);
          document.removeEventListener('drop',     h, true);
          overlayEl.__suppressOutsideDnD = null;
      }
      window.__FM_ACTIVE = false;

      // Hard cleanup of REPL after File Manager.
      if (typeof window.fmForceCleanup === 'function') {
        try { window.fmForceCleanup(); } catch(e) { console.warn(e); }
      }
    }

  </script>


  <script>
    // Register service worker in the web build.
    if (!isElectron) {

      if ('serviceWorker' in navigator) {
            const SW_URL = `/esp_ide_v2/sw.js?v=${encodeURIComponent(SW_VERSION)}`;
            navigator.serviceWorker.register(SW_URL, { scope: '/esp_ide_v2/', updateViaCache: 'none' })
              .then((reg) => {
                // Ensure a waiting worker activates ASAP.
                if (reg.waiting) reg.waiting.postMessage('skipWaiting');
                reg.addEventListener('updatefound', () => {
                  const worker = reg.installing;
                  if (!worker) return;
                  worker.addEventListener('statechange', () => {
                    if (worker.state === 'installed' && navigator.serviceWorker.controller) {
                      worker.postMessage('skipWaiting');
                    }
                  });
                });
                // Periodic update check.
                setInterval(() => reg.update(), 240 * 60 * 1000);
              })
              .catch((e) => console.warn('SW register failed', e));

            // Reload once after a new SW takes control.
            navigator.serviceWorker.addEventListener('controllerchange', () => {
              if (window.__swReloaded) return;
              window.__swReloaded = true;
              window.location.reload();
            });
        }
    }


    // Disable unsupported buttons in Electron.
    if (isElectron) {


		const btn = document.getElementById('joy-btn') || document.querySelector('button[onclick*="openJoy_App"]');
		if (btn) {
          btn.disabled = true;
          btn.setAttribute('aria-disabled', 'true');
          btn.title = t('errors.notSupportedInElectron');
          btn.style.opacity = '0.6';
          btn.style.cursor = 'not-allowed';
          btn.onclick = (e)=>{ e.preventDefault(); e.stopPropagation(); return false; };
        }

		/*
        const btn_install = document.getElementById('install_fw-btn') || document.querySelector('button[onclick*="openJoy_App"]');
        if (btn_install) {
          btn_install.disabled = true;
          btn_install.setAttribute('aria-disabled', 'true');
          btn_install.title = t('errors.notSupportedInElectron');
          btn_install.style.opacity = '0.6';
          btn_install.style.cursor = 'not-allowed';
          btn_install.onclick = (e)=>{ e.preventDefault(); e.stopPropagation(); return false; };
        }
		*/
    }
  </script>

</body>
</html>
